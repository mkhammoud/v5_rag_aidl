{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"page_content": "{Lesson 3: Functions and Modular Programming [240 mins]}\n\\subsection{Introduction}\nFunctions are the building blocks of any programming language, and they play an important role in making code more organized, readable, and reusable. \n\nFunctions allow us to break down complex tasks into smaller, manageable pieces, promoting modularity, and enhancing the overall structure of our code.\n\nIn this lesson, we'll learn about functions, exploring their significance in Python and how they facilitate the development of AI applications. We'll start with the basics, gradually building your skills in writing, using, and understanding functions. By the end of this week, you'll not only be equipped with the knowledge of how to create functions but also comprehend why they are fundamental to becoming a proficient Python programmer, especially in the context of AI development. Let's start exploring functions!\n\n\\subsection{Creating and Calling a Function}\nYou've already encountered some built-in functions like print(), input(), and len() in the previous chapters. Python provides a range of these pre-defined functions to perform various tasks. However, what makes Python truly powerful is its capability to let us create our own functions. Think of a function as a mini-program within your main program, and they're an essential concept to grasp as we journey into Python for AI.\n\nTo gain a deeper understanding of how functions operate, let's create one together. \n\n\\begin{lstlisting}[language=Python]\ndef greet():\n    print('Welcome to the world of Python!')\n    print('Get ready to explore AI with Python!')\n    print('Let your Python journey begin!')\n\ngreet()\ngreet()\ngreet()\n\\end{lstlisting}\n\nThe first line, starting with 'def,' is a defining statement for a function, which in this case, we've named 'greet()'. The code enclosed within the following indented block is the body of the function. This block of code executes only when the function is called, not when it's initially defined.\n\nThe lines where we use 'greet()' after the function definition are function calls. In Python, a function call consists of the function's name followed by parentheses. When the program reaches these calls, it immediately jumps to the top line of the function and starts executing the code within. Once it reaches the end of the function, it returns to the line that invoked the function and continues executing the remaining code.\n\nSince we've called 'greet()' three times in this program, the code within 'greet()' is executed thrice. When we run this program, the output will look like this:\n\nOutput:\n\\begin{lstlisting}[language=Python]\nWelcome to the world of Python!\nGet ready to explore AI with Python!\nLet your Python journey begin!\nWelcome to the world of Python!\nGet ready to explore AI with Python!\nLet your Python journey begin!\nWelcome to the world of Python!\nGet ready to explore AI with Python!\nLet your Python journey begin!\n\\end{lstlisting}\n\nA primary purpose of functions is to encapsulate and reuse code that needs to be executed multiple times. Without functions, we'd have to duplicate or copy-paste this code every time we want it to run, leading to repetitive and error-prone programs, like this:\n\n\\begin{lstlisting}[language=Python]\nprint('Welcome to the world of Python!')\nprint('Get ready to explore AI with Python!')\nprint('Let your Python journey begin!')\nprint('Welcome to the world of Python!')\nprint('Get ready to explore AI with Python!')\nprint('Let your Python journey begin!')\nprint('Welcome to the world of Python!')\nprint('Get ready to explore AI with Python!')\nprint('Let your Python journey begin!')\n\\end{lstlisting}\n\nIn practice, we always want to avoid duplicating code because updating it later, for instance, to change the messages, would require changes in multiple places. As our programming skills grow, we'll often find ourselves deduplicating code, which means removing redundancy and making our programs shorter, more readable, and easier to maintain.\n\n\\subsection{Function Arguments or Parameters}\nIn Python programming, functions like print() or len() are often given information to work with, which we call arguments or parameters. In a similar fashion, we can create our own functions that accept arguments. These arguments are useful for use inside the function. Sometimes, we need to pass some information to a function to work with, which we do using parameters. Let's explore this concept by creating a new example. Let's update the previously defined greet function by adding a parameter called 'name'.\n\\begin{lstlisting}[language=Python]\ndef greet_with_name(name):\n    print('Hello ' + name + '! Welcome to the world of Python and AI.')\n\ngreet_with_name('Alice')\ngreet_with_name('Bob')\n\\end{lstlisting}\n\nHere's what's happening in this program:\n\nThe \\textbf{greet\\_with\\_name()} function definition in this program has a parameter named 'name'. A parameter is like a placeholder for the value that will be provided when the function is called. When we call the \\textbf{greet\\_with\\_name()} function the first time, as in \\textbf{greet\\_with\\_name('Alice')}, 'Alice' is the argument provided. The program execution enters the function, and the parameter 'name' is automatically set to 'Alice,' which is what gets printed by the \\textbf{print()} statement.\n\nThe second call to \\textbf{greet\\_with\\_name()} with 'Bob' as an argument works in the same way, and 'Bob' is substituted for 'name' within the function.\n\nOne important thing to understand about parameters is that the value stored in a parameter is temporary and exists only while the function is running. Once the function finishes executing, the parameter value is forgotten. For example, if we were to add \\textbf{print(name)} after \\textbf{greet\\_with\\_name('Bob')} in the previous program, it would result in a NameError. This is because 'name' exists only within the scope of the \\textbf{greet\\_with\\_name()} function, and it's discarded after the function call \\textbf{greet\\_with\\_name('Bob')} finishes.\n\nThis behavior is similar to how program variables are forgotten when the program finishes executing. We'll delve into more detail about this concept, known as a function's local scope, later in this chapter. Understanding scope is essential as we progress in Python programming.\n\nLet us consider another example, where we show how to pass a list as an argument to a function.\n\\begin{lstlisting}[language=Python]\ndef print_list_elements(my_list):\n    for item in my_list:\n        print(item)\n\nmy_list1 = [1, 2, 3, 4, 5]\nmy_list2 = ['apple', 'banana', 'cherry', 'date']\n\nprint(\"Printing elements of my_list1:\")\nprint_list_elements(my_list1)\n\nprint(\"Printing elements of my_list2:\")\nprint_list_elements(my_list2)\n\\end{lstlisting}\nIn this example, we have a function that takes a list as a parameter. This function contains a loop that iterates over the list and print its elements. Afterward, we call the function twice with two different lists. The first list 'my\\_list1' contains numbers, while 'my\\_list2' has strings.\n\n\\subsection{Function Returns}\nIn Python, functions are not only used to perform actions but also to provide results or data back to the caller. This concept is where the return statement comes into play. When we call a function, it can calculate or process data and then hand back the result using the return statement. Let's take an example:\n\\begin{lstlisting}[language=Python]\ndef calculate_square_area(side_length):\n    # Calculate the area of a square\n    return side_length * side_length\n\n# Let's find the area of two squares with different side lengths\nside_length_1 = 5\nside_length_2 = 8\n\narea_1 = calculate_square_area(side_length_1)\narea_2 = calculate_square_area(side_length_2)\n\nprint(f\"The area of a square with side length {side_length_1} is {area_1}.\")\nprint(f\"The area of a square with side length {side_length_2} is {area_2}.\")\n\\end{lstlisting}\n\nNow, let's explain what's happening in this new example:\n\nIn Python, when we call a function like \\textbf{len()} with an argument, such as a string like 'Hello', the function evaluates to a value, in this case, an integer, which is 5, representing the length of the string.\n\nWe can specify what value a function should return using a \\textbf{return} statement. This statement consists of two parts:\n\n\\begin{itemize}\n    \\item The \\textbf{return} keyword.\n    \\item The value or expression that the function should return.\n\\end{itemize}\n\nFor example, in this program, we define a function called \\textbf{calculate\\_square\\_area(side\\_length)} which calculates and returns the area of a square given its side length.\n\nHere's what happens in this program:\n\n\\begin{enumerate}\n    \\item We define a function \\textbf{calculate\\_square\\_area(side\\_length)} that takes a \\textbf{side\\_length} as an argument and calculates the area of a square using the formula \\textbf{side\\_length * side\\_length}. The result is returned using the \\textbf{return} statement.\n    \\item We then proceed to find the area of two squares with different side lengths, \\textbf{side\\_length\\_1} and \\textbf{side\\_length\\_2}.\n    \\item We call the \\textbf{calculate\\_square\\_area()} function with \\textbf{side\\_length\\_1} and \\textbf{side\\_length\\_2}, and the returned values are stored in \\textbf{area\\_1} and \\textbf{area\\_2}.\n    \\item Finally, we print out the areas of the squares with their respective side lengths.\n\\end{enumerate}\n\nIt's worth noting that since we can use return values as arguments in other function calls, we can make your code more concise. For example, the lines that calculate the area and assign it to \\textbf{area\\_1} and \\textbf{area\\_2} can be simplified into a single line using a function call within the print() statement.\n\nUnderstanding how functions return values is crucial as it allows us to create reusable and modular code, enhancing the efficiency and readability of our programs.\n\n\\subsection{Local and Global Scope}\nIn Python, scope refers to the region in your code where a variable is defined and can be accessed. There are two main types of scope: local scope and global scope, and these scopes play a significant role when working with functions.\n\n\\begin{enumerate}\n    \\item \\textbf{Local Scope:}\n    \\begin{itemize}\n        \\item \\textbf{Definition:} Local scope refers to the area within a function where variables are defined. Variables created inside a function are said to have local scope.\n        \\item \\textbf{Visibility:} Variables with local scope are only accessible within the function where they are defined. They cannot be accessed from outside the function.\n        \\item \\textbf{Lifetime:} Variables with local scope have a limited lifetime. They are created when the function is called and destroyed when the function completes execution.\n        \\item Example:\n\\begin{lstlisting}[language=Python]\ndef my_function():\n    x = 10  # x has local scope\n    print(x)\n        \nmy_function()\n# Accessing x here would result in an error because it's a local variable.\n\\end{lstlisting}\n    \\end{itemize}\n    \\item \\textbf{Global Scope:}\n    \\begin{itemize}\n        \\item \\textbf{Definition:} Global scope refers to the area outside of any function where variables are defined. Variables created at the top level of a script or module are said to have global scope.\n        \\item \\textbf{Visibility:} Variables with global scope are accessible from any part of the code, including inside functions.\n        \\item \\textbf{Lifetime:} Variables with global scope exist throughout the entire program's execution.\n        \\item Example:\n\\begin{lstlisting}[language=Python]\nx = 10  # x has global scope\n\ndef my_function():\n    print(x)  # Accessing the global variable x\n\nmy_function()\n# We can also access x here because it's a global variable.\n\\end{lstlisting}\n    \\end{itemize}\n\\end{enumerate}\n\nHere's a key point to remember:\n\n\\begin{itemize}\n    \\item When we create a variable inside a function, it has local scope and is separate from any variable with the same name in the global scope. Changes to the local variable do not affect the global variable, and vice versa.\n\\end{itemize}\n\nFor example:\n\\begin{lstlisting}[language=Python]\nx = 10  # Global variable\n\ndef my_function():\n    x = 5  # This creates a new local variable x\n    print(x)  # Prints the local x\n\nmy_function()\nprint(x)  # Prints the global x (10)\n\\end{lstlisting}\n\nIn this example, there are two variables named \\textbf{x}, one with local scope inside the function and one with global scope outside the function. They are distinct, and changes to one do not affect the other.\n\nUnderstanding and managing variable scope is crucial for writing maintainable and bug-free code. It allows us to control the visibility and lifetime of variables. \n\n\\subsection{Summary}\nIn our functions lesson, we explored the essential concept of functions in Python. Functions act as  reusable blocks of code that bring order and organization to our programs.\n\nWe began by understanding that functions are like mini-programs within your code. They are defined using the \\textbf{def} statement and can be called to execute their specific tasks whenever needed.\n\nWe saw how functions can take in arguments, which are values or data that the function can work with. These arguments provide flexibility and dynamism to your functions.\n\nMoreover, we learned about return values and return statements, which allow functions to share results or data with the rest of the program.\n\nAdditionally, we discussed scope, the idea that variables can have local or global visibility, depending on where they are defined. This knowledge is important for managing variables effectively in your code.\n\nAs we will discover later in the course, the core dataset handling and AI functionalities are defined in the form of functions, which we can use in our code to build our solutions.\n\n\\subsection{Practical Exercise: Functions [60 mins]}\n\\subsubsection*{Your task}\nThe task is to convert the previous code we created for the practical exercises of dictionaries into functions. For each of the six tasks from the dictionaries lesson (Section 2.15), create a function that takes the data as a parameter and returns that desired output. For example:\n\n\\begin{lstlisting}[language=Python]\ndef countChestPainType(data):\n    chest_pain_counts = {}\n    ...\n    return chest_pain_counts\n\n# Calling the function\nchest_pain_counts = countChestPainType(data)\n\\end{lstlisting}\n\nRepeat this for each of the tasks in the previous lesson, then call each function and print the desired output.\n\nBelow are the tasks you have to create functions for:\n\n\\begin{enumerate}\n    \\item Count the occurrences of chest pain type in the dataset. To achieve this, create a dictionary that keeps count of how many times each chest pain type appears in the dataset.\n    \\item Create a dictionary of patients with high cholesterol level. Store in this dictionary the full information about patients with high cholesterol (cholesterol level greater than 360). To do so, iterate through each data point, convert the 'Cholesterol' value to an integer, and check if it's greater than 200. If it is, we add the entire data point to the dictionary, using the patient's age as the key.\n    \\item Calculate Average Max Heart Rate for Male and Female Patients. Use two dictionaries to keep track of the sum of max heart rates and the count of patients for each gender. Iterate through the dataset, convert the 'MaxHR' value to an integer, and based on the patient's sex, update the respective dictionary. After processing all data points, we need to calculate the averages and print them.\n    \\item Find the Patient with the Highest Cholesterol. Iterate through the dataset and compare each patient's cholesterol level to the highest recorded so far. Store the entire data point for the patient with the highest cholesterol and finally print it.\n    \\item Group Patients by Age Range. Create a dictionary to group patients into different age ranges: '18-30', '31-40', '41-50', '51-60', '61+'. Iterate through the dataset and based on the patient's age, append the data point to the corresponding age group list within the dictionary. Finally, print the size of the list for each age group. \n    \\item Calculate the Percentage of Patients with Heart Disease. Iterate through the dataset and increment the count whenever we encounter a patient with heart disease ('HeartDisease' equal to '1'). Finally, calculate the percentage and print it.\n\\end{enumerate}\n\nWe have included the Jupyter notebook as model answers for these exercises.\n\n\\subsubsection*{Model Answers}\nBelow are the model answers for each task:\n\\begin{enumerate}\n    \\item {\n    \\begin{lstlisting}[language=Python]\ndef calculate_chest_pain_counts(data):\n    # Initialize an empty dictionary to store the counts of each chest pain type\n    chest_pain_counts = {}\n\n    # Loop through the dataset\n    for data_point in data:\n        chest_pain_type = data_point['ChestPainType']\n        if chest_pain_type in chest_pain_counts:\n            chest_pain_counts[chest_pain_type] += 1\n        else:\n            chest_pain_counts[chest_pain_type] = 1\n\n    return chest_pain_counts\n\n# Call the function with your dataset (assuming you have already loaded the data)\nresult = calculate_chest_pain_counts(data)\nprint(result)\n    \\end{lstlisting}\n    }\n    \\item {\n    \\begin{lstlisting}[language=Python]\ndef find_high_cholesterol_patients(data):\n    # Initialize an empty dictionary to store patients with high cholesterol\n    high_cholesterol_patients = {}\n\n    # Loop through the dataset\n    for data_point in data:\n        cholesterol = int(data_point['Cholesterol'])\n        if cholesterol > 360:\n            high_cholesterol_patients[data_point['Age']] = data_point\n\n    return high_cholesterol_patients\n\n# Call the function with your dataset (assuming you have already loaded the data)\nresult = find_high_cholesterol_patients(data)\nprint(result)\n    \\end{lstlisting}\n    }\n    \\item {\n    \\begin{lstlisting}[language=Python]\ndef calculate_average_max_hr(data):\n    # Initialize dictionaries to store sums and counts for max heart rates of male and female patients\n    male_max_hr = {'sum': 0, 'count': 0}\n    female_max_hr = {'sum': 0, 'count': 0}\n\n    # Loop through the dataset\n    for data_point in data:\n        max_hr = int(data_point['MaxHR'])\n        if data_point['Sex'] == 'M':\n            male_max_hr['sum'] += max_hr\n            male_max_hr['count'] += 1\n        else:\n            female_max_hr['sum'] += max_hr\n            female_max_hr['count'] += 1\n\n    # Calculate average max heart rates\n    average_male_max_hr = male_max_hr['sum'] / male_max_hr['count']\n    average_female_max_hr = female_max_hr['sum'] / female_max_hr['count']\n\n    return average_male_max_hr, average_female_max_hr\n\n# Call the function with your dataset (assuming you have already loaded the data)\nmale_avg, female_avg = calculate_average_max_hr(data)\nprint(\"Average Max Heart Rate (Male):\", male_avg)\nprint(\"Average Max Heart Rate (Female):\", female_avg)\n    \\end{lstlisting}\n    }\n    \\item {\n    \\begin{lstlisting}[language=Python]\ndef find_patient_with_highest_cholesterol(data):\n    # Initialize variables to keep track of the highest cholesterol and the corresponding patient\n    highest_cholesterol = 0\n    patient_with_highest_cholesterol = None\n\n    # Loop through the dataset\n    for data_point in data:\n        cholesterol = int(data_point['Cholesterol'])\n        if cholesterol > highest_cholesterol:\n            highest_cholesterol = cholesterol\n            patient_with_highest_cholesterol = data_point\n\n    return patient_with_highest_cholesterol\n\n# Call the function with your dataset (assuming you have already loaded the data)\nhighest_cholesterol_patient = find_patient_with_highest_cholesterol(data)\nprint(\"Patient with the Highest Cholesterol:\", highest_cholesterol_patient)\n    \\end{lstlisting}\n    }\n    \\item {\n    \\begin{lstlisting}[language=Python]\ndef group_patients_by_age(data):\n    # Initialize a dictionary to group patients by age range\n    age_groups = {'18-30': [], '31-40': [], '41-50': [], '51-60': [], '61+': []}\n\n    # Loop through the dataset\n    for data_point in data:\n        age = int(data_point['Age'])\n        if age <= 30:\n            age_groups['18-30'].append(data_point)\n        elif age <= 40:\n            age_groups['31-40'].append(data_point)\n        elif age <= 50:\n            age_groups['41-50'].append(data_point)\n        elif age <= 60:\n            age_groups['51-60'].append(data_point)\n        else:\n            age_groups['61+'].append(data_point)\n\n    return age_groups\n\n# Call the function with your dataset (assuming you have already loaded the data)\nresult_age_groups = group_patients_by_age(data)\n\n# Print the number of patients in each age group\nprint(\"Patients in Age Group 18-30:\", len(result_age_groups['18-30']))\nprint(\"Patients in Age Group 31-40:\", len(result_age_groups['31-40']))\n# Repeat for other age groups...\n    \\end{lstlisting}\n    }\n    \\item {\n    \\begin{lstlisting}[language=Python]\ndef calculate_percentage_with_heart_disease(data):\n    # Initialize variables to keep track of the total number of patients and patients with heart disease\n    total_patients = len(data)\n    heart_disease_patients = 0\n\n    # Loop through the dataset\n    for data_point in data:\n        if data_point['HeartDisease'] == '1':\n            heart_disease_patients += 1\n\n    percentage_with_heart_disease = (heart_disease_patients / total_patients) * 100\n\n    return percentage_with_heart_disease\n\n# Call the function with your dataset (assuming you have already loaded the data)\npercentage = calculate_percentage_with_heart_disease(data)\nprint(\"Percentage of Patients with Heart Disease:\", percentage, \"%\")\n    \\end{lstlisting}\n    }\n\\end{enumerate}\n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]", "metadata": {"source": "./full-course/aai.txt"}}}