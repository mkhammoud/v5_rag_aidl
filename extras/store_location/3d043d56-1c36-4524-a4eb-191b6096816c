{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"page_content": "{Lesson 1: Classes and Object-Oriented Programming in Python  [240 mins]}\n\\subsection{Introduction}\nObject-oriented programming is a powerful paradigm that enables us to structure our code in a way that models real-world entities, making our code more organized, modular, and easier to manage. It basically divides our code into pieces. Imagine developing a huge Artificial Intelligence application in just 1 small coding page; it will be extremely difficult to manage. Throughout this lesson, we will discuss the fundamental concepts of classes and objects in Python, and explore how to create and manipulate custom objects. \n\n\n\\subsection{Motivation: Native Data Types vs Custom Objects}\nAs we previously addressed the properties of each data type, we notice that they are limited in terms of features. Imagine that we are building a racing computer game. It will be difficult to represent everything with integers and other simple data types. Many cars are supposed to exist in the game and they all have their own characteristics and interactions with the other cars and with their surrounding. \n\nCustom objects offer us a great advantage in such a case. We can create an object called Car, and this car will encapsulate all the car characteristics and interactions, reflecting the real-world concept of a car in the game. \n\nMoreover, once the custom object is designed, it can then be used in other places/projects. This will help us reduce the time we take to write programs/games. Think about it like we are developing an object called Car for our cars game. The same Car module can then be used to be placed in other games as well - of course with the needed modifications.\n\n\n\n\n\n\\subsection{Class Introduction}\nA class is a fundamental concept that allows us to define a blueprint for creating objects. The methods that the object use are defined within this class. For example, our previous example was about the car. \n\n\n\n\n\\subsection{Defining a Class}\nThe way to define a class is by the keyword class. The class usually starts with a capital letter. After the two points, we go to a new line and then we write the properties of this class and the custom methods it has. More elaboration on the in the next sections. An example of a Car class could be the following:\n\\textbf{\\textit{example 1: Car class}}\n\\begin{lstlisting}[language=Python]\nclass Car:\n  color = \"red\"\n  seats = 5\n\\end{lstlisting}\n\nAnother example of a class that represents Drivers could be the following:\n\\textbf{\\textit{example 2: Driver class}}\n\\begin{lstlisting}[language=Python]\nclass Driver:\n  age = 35\n\\end{lstlisting}\n\n\\subsection{Creating Objects}\n\\subsubsection{Creating a single object}\nAn object is what can be obtained when defining a new entity of the class. For example, let us assume the aforementioned class (Car). The way to utilize that class in the context of programming is to directly call it. An example can be the following:\n\\begin{lstlisting}[language=Python]\nclass Car:\n  color = \"red\"\n  seats = 5\n\ntoyota = Car()\nprint(type(toyota)) #output <class '__main__.Car'>\n\\end{lstlisting}\nWe define a new variable called \\textit{toyota} to be an instance of a Car. We put parenthesis after the class name to define an instance of it. Afterward, we print the type of the variable \\textit{toyota} to see what it is. It should be something similar to \\textit{\"class \\_\\_main\\_\\_.Car\"}. \n\n\\subsubsection{Creating multiple objects}\nIt is very likely that we created a class to use it for more than one object. For example, assume that we want to utilize two car objects. The first one is for toyota, and the second one is for honda. The example below can show how it can be done:\n\n\\begin{lstlisting}[language=Python]\nclass Car:\n  color = \"red\"\n  seats = 5\n\ntoyota = Car()\nhonda = Car()\n\\end{lstlisting}\nIn the next sections, we will elaborate on how we print the properties of an object.\n\n\n\\subsection{Properties}\nAs we described before the concepts of Objects and Classes, Properties are the characteristics of the objects. And their structure is usually written down in the Class definition. A class can have multiple properties or no properties at all. \n\n\\begin{lstlisting}[language=Python]\nclass Car:\n  color = \"red\"\n  seats = 5\n\\end{lstlisting}\nA car for example, as defined above, has two characteristics (properties), the first one is its color, and the second one is the number of seats it has. Thus, when we utilize the Object Car, its color will be defined as \"red\" and its number of seats will be \"5\". We can retrieve the properties by calling them, like the following example:\n\n\\begin{lstlisting}[language=Python]\nclass Car:\n  color = \"red\"\n  seats = 5\n\ntoyota = Car()\nprint(toyota.color) #output red\nprint(toyota.seats) #output 5\n\\end{lstlisting}\nBy simply typing the variable name and the property name, separated by a dot, we can access the property of the object.\n\nProperties can also be modified. Simply, we can change the property after calling it like the following:\n\\begin{lstlisting}[language=Python]\nclass Car:\n  color = \"red\"\n  seats = 5\n\ntoyota = Car()\n\n#printing the old color\nprint(toyota.color) #output red\n#updating the color\ntoyota.color = \"silver\"\n#printing the new color\nprint(toyota.color) #output silver\n\n#printing the old seats\nprint(toyota.seats) #output 5\n#updating the seats\ntoyota.seats = 7\n#printing the new seats\nprint(toyota.seats) #output 7\n\n\\end{lstlisting}\nIn the previous example, we called the two properties and changed them into something else. Then we printed them to show how they changed. At any line now in the previous code, toyota will always have the color and seats to be silver and 7, respectively, until we change them again.\n\n\n\n\\subsection{The Self}\nSelf is the first argument for every method. Any time we refer we update the Object from within the Class itself, we must refer to it by the Self. The purpose of its utilization is to distinguish the variables and methods from other variables and functions in the program. \n\n\\subsection{Methods}\nBesides the properties, Methods consist of a big part of the classes.  Methods are functions that are associated with a class and operate on its attributes. \n\\subsubsection{Constructors}\nIn this section, we will discuss how we can create a custom object out of a class without the need of accessing its properties after its creation. A constructor is automatically called when someone creates a new object from the class. We usually use the constructor to set the variables of the new object. A special method for constructors in almost every class called \\textit{\\_\\_init\\_\\_}, can be used to set/change the values of an object while it is being created.\n\\begin{lstlisting}[language=Python]\nclass Car:\n  color = \"red\"\n  seats = 5\n\n  def __init__(self, new_color, new_seats):\n    self.color = new_color\n    self.seats = new_seats\n\n#The rest of the code below does not belong inside the car class.\n#Always focus on the indentation to tell.\n\ntoyota = Car(\"blue\", 2)\nprint(toyota.color) #output red\nprint(toyota.seats) #output 5\n\\end{lstlisting}\n\nThe method \\textit{\\_\\_init\\_\\_(self, new\\_color, new\\_seats)} is used to set up the object when it will be created. The first argument of almost every method starts with a \\textit{self} parameter. \n\\begin{itemize}\n    \\item \\textbf{self.color = new\\_color}: it changes the default color of the Car to the color provided when the Car is defined.\n    \\item \\textbf{self.seats = new\\_seats}: it changes the default seats of the Car to the seats provided when the Car is defined.\n\\end{itemize}\nPrecisely, this function is called when the programmer writes the name of the class with the desired parameters. Since we set 2 parameters (in addition to the self param), we are forced now to set these arguments when we call the class. \\textit{toyota = Car(\"blue\", 2)} is an example that returns a modified object Car that is blue and has 2 seats.\n\n\\textbf{Additional notes:} We can simplify the definition of color and seats at the beginning of the classes since we are defining them in the \\textit{init} method (or in any other method, although it is very rare to define properties in other methods). The code below has the same behavior as the one above. \n\\begin{lstlisting}[language=Python]\nclass Car:\n  def __init__(self, new_color, new_seats):\n    self.color = new_color\n    self.seats = new_seats\n\ntoyota = Car(\"blue\", 2)\nprint(toyota.color) #output red\nprint(toyota.seats) #output 5\n\\end{lstlisting}\ncolor and seats are now defined directly inside the init method. Also, since now we have an init method, we cannot create an object like the way we did it in the previous section (i.e., \\textit{toyota = Car()}) because now, every car has to have a color and a seat in their initialization. Therefore, in this case, we always have to give 2 parameters to every newly created Car.\n\n\\subsubsection{Objects to String}\nIn Python, a default method also exists which is called \\textit{\\_\\_str\\_\\_(self)}. This method usually prints the object reference in the computer memory. However, it can be modified to whatever we want.\n\\begin{lstlisting}[language=Python]\nclass Car:\n  def __init__(self, new_color, new_seats):\n      self.color = new_color\n      self.seats = new_seats\n  def __str__(self):\n      return \"Car: color \" + self.color + \", seats \" + str(self.seats)\n\ntoyota = Car(\"blue\", 2)\nhonda = Car(\"silver\", 5)\nkia = Car(\"red\", 4)\n\nprint(toyota)\nprint(honda)\nprint(kia)\n\\end{lstlisting}\nThe str method always returns a string. In the previous example, we modified the str method to return a description of the object. The output if the previous example will be:\n\\begin{lstlisting}\n    Car: color blue, seats 2\n    Car: color silver, seats 5\n    Car: color red, seats 4\n\\end{lstlisting}\n\n\n\n\\subsubsection{Custom Methods}\nBesides the aforementioned method, Python allows for customizing whatever method is needed inside of the classes. Let's check the following example:\n\n\n\\begin{lstlisting}[language=Python]\nclass Car:\n    def __init__(self, new_color, new_seats, odometer):\n        self.color = new_color\n        self.seats = new_seats\n        self.odometer = odometer\n\n    def __str__(self):\n        return \"Car: color \" + self.color + \", seats \" + str(self.seats) + \", odometer \" + str(self.odometer)\n\n    def is_car_new(self):\n        return self.odometer == 0\n\n\ntoyota = Car(\"blue\", 2, 0)\nhonda = Car(\"silver\", 5, 100000)\n\nif toyota.is_car_new():\n    print(\"toyota is new\")\nelse:\n    print(\"toyota is used\")\n\nif honda.is_car_new():\n    print(\"honda is new\")\nelse:\n    print(\"honda is used\")\n\\end{lstlisting}\nIn the previous example, we created a new custom method called \\textit{is\\_car\\_new} and we included a new property that indicates how many kilometers the car was used for \\textit{odometer}. The method is\\_car\\_new takes \\textit{self} as an argument because it needs to access the information of the car, the odometer property. We return True if the car has not been driven yet. \nIn the testing phase at the end of the above code, we are calling this method through the object itself. For instance, if we want to check whether toyota is new or not, we call \\textit{toyota.is\\_car\\_new()}.\n\n\\subsubsection{Custom Methods with Arguments}\nCustomized methods may also take additional arguments, depending on what they are intended to do. For example, let us assume we want to create two methods, one that checks whether two cars have the same number of seats or not. And another method returns the total number of odometers with 2 other cars.\n\\begin{lstlisting}[language=Python]\nclass Car:\n    def __init__(self, new_color, new_seats, odometer):\n        self.color = new_color\n        self.seats = new_seats\n        self.odometer = odometer\n\n    def has_same_number_of_seats(self, car2): #function1\n        if self.seats == car2.seats:\n            has_same_seats = True\n        else:\n            has_same_seats = False\n        return has_same_seats\n\n    def combine_all_odometers(self, car2, car3): #function2\n        return self.odometer + car2.odometer + car3.odometer\n\ntoyota = Car(\"blue\", 2, 0)\nhonda = Car(\"silver\", 5, 100000)\nmazda = Car(\"silver\", 3, 1500)\n\n\n#call for the first function\nif honda.has_same_number_of_seats(toyota):\n    print(\"both cars have the same number of seats!\")\nelse:\n    print(\"the number of seats is different!\")\n\n\n#call of the second function \nprint(\"the aggregated value of all odometers is\", toyota.combine_all_odometers(honda, mazda))\n\n\n\\end{lstlisting}\nNotice the new method \\textit{'has\\_same\\_number\\_of\\_seats' (function1)}. This method takes 2 arguments, the first is the self (the object calling the function), and another parameter we call it \\textit{'car2'}.\nThe additional argument, car2, is treated in this exercise as an object of type \\textit{Car}. We access the seats of the calling object \\textit{-the self-} and of the passed object \\textit{-car2-}. Notice how we access the properties of both of these objects differently.\nWe also added another method \\textit{'combine\\_all\\_odometers' (function2)}. This method is more straightforward with its content; simply it adds all the odometers together. However, notice how we have 2 other parameters in addition to the self. Both car2 and car3 are Objects of type \\textit{Car}. And both of their properties are being accessed inside of this function, in addition to the object who is calling the function (self).\n\n\\subsubsection{Calling Methods from Within Classes}\nJust like how we can access properties from within a class using the \\textit{self}, we can also access methods. Simply, by calling the name of the method next to self, like: \\textit{self.has\\_same\\_number\\_of\\_seats(...)}.\n\\begin{lstlisting}[language=Python]\nclass Car:\n    def __init__(self, new_color, new_seats, odometer):\n        self.color = new_color\n        self.seats = new_seats\n        self.odometer = odometer\n\n    def has_same_number_of_seats(self, car2): #function1\n        if self.seats == car2.seats:\n            has_same_seats = True\n        else:\n            has_same_seats = False\n        return has_same_seats\n\n    def has_same_color(self, car2):\n        return self.color == car2.color\n        \n    def is_car_similar(self, car2):\n        same_seats = self.has_same_number_of_seats(car2)\n        same_color = self.has_same_color(car2)\n        return same_seats and same_color \n        \ntoyota = Car(\"blue\", 2, 0)\nhonda = Car(\"silver\", 5, 100000)\nmazda = Car(\"blue\", 2, 1500)\n\nif toyota.is_car_similar(honda):\n    print(\"toyota and honda are similar\")\nelse:\n    print(\"toyota and honda are not similar\")\n\nif toyota.is_car_similar(mazda):\n    print(\"toyota and mazda are similar\")\nelse:\n    print(\"toyota and mazda are not similar\")\n\n\n\\end{lstlisting}\n\nNotice in the previous example how we created a method called \\textit{is\\_car\\_similar}, and inside this method, we are calling two methods that belong to the self, i.e., \\textit{has\\_same\\_number\\_of\\_seats} and \\textit{has\\_same\\_color}.\n\n\n\\subsection{Medical Class: A Use Case}\nLet us assume that we are dealing with the previous medical application we were addressing last week. What if we are dealing with multiple dataset?\n\nWe can split the program into several pieces: 1- The modules to be imported (more on that in later lessons), 2- the class properties, and 3- the class functions. We import the functions used in last week's exercise and write them here while applying the necessary modifications.\nBelow is a video that can walk us through the code.\n\n\\includegraphics[width=\\textwidth]{Images/video_resource.png} \n%VIDEO ID: LAU AAI2 W5 L1 Medical Class: A Use Case\n\n\n\\begin{lstlisting}[language=Python]\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\nimport seaborn as sns\npd.options.display.float_format = '{:.2f}'.format\nimport warnings\nwarnings.filterwarnings('ignore')\n\n\nclass MedicalDataset:\n\n    data = []\n\n    def __init__(self, dataset_path):\n        import csv\n        with open(dataset_path, mode='r') as csv_file:\n            # Create a CSV reader object\n            csv_reader = csv.DictReader(csv_file)\n            # Loop through each row in the CSV file\n            for row in csv_reader:\n                # Append each row (as a dictionary) to the data list\n                self.data.append(row)\n       \n    def calculate_chest_pain_counts(self):\n        # Initialize an empty dictionary to store the counts of each chest pain type\n        chest_pain_counts = {}    \n        # Loop through the dataset\n        for data_point in self.data:\n            chest_pain_type = data_point['ChestPainType']\n            if chest_pain_type in chest_pain_counts:\n                chest_pain_counts[chest_pain_type] += 1\n            else:\n                chest_pain_counts[chest_pain_type] = 1\n        return chest_pain_counts\n\n    def find_high_cholesterol_patients(self):\n        # Initialize an empty dictionary to store patients with high cholesterol\n        high_cholesterol_patients = {}\n        # Loop through the dataset\n        for data_point in self.data:\n            cholesterol = int(data_point['Cholesterol'])\n            if cholesterol > 360:\n                high_cholesterol_patients[data_point['Age']] = data_point\n        return high_cholesterol_patients\n\n    def calculate_average_max_hr(self):\n        # Initialize dictionaries to store sums and counts for max heart rates of male and female patients\n        male_max_hr = {'sum': 0, 'count': 0}\n        female_max_hr = {'sum': 0, 'count': 0}\n        # Loop through the dataset\n        for data_point in self.data:\n            max_hr = int(data_point['MaxHR'])\n            if data_point['Sex'] == 'M':\n                male_max_hr['sum'] += max_hr\n                male_max_hr['count'] += 1\n            else:\n                female_max_hr['sum'] += max_hr\n                female_max_hr['count'] += 1\n        # Calculate average max heart rates\n        average_male_max_hr = male_max_hr['sum'] / male_max_hr['count']\n        average_female_max_hr = female_max_hr['sum'] / female_max_hr['count']\n        return average_male_max_hr, average_female_max_hr\n\n\n    def find_patient_with_highest_cholesterol(self):\n        # Initialize variables to keep track of the highest cholesterol and the corresponding patient\n        highest_cholesterol = 0\n        patient_with_highest_cholesterol = None\n        # Loop through the dataset\n        for data_point in self.data:\n            cholesterol = int(data_point['Cholesterol'])\n            if cholesterol > highest_cholesterol:\n                highest_cholesterol = cholesterol\n                patient_with_highest_cholesterol = data_point\n        return patient_with_highest_cholesterol\n\n    def group_patients_by_age(self):\n        # Initialize a dictionary to group patients by age range\n        age_groups = {'18-30': [], '31-40': [], '41-50': [], '51-60': [], '61+': []}\n        # Loop through the dataset\n        for data_point in self.data:\n            age = int(data_point['Age'])\n            if age <= 30:\n                age_groups['18-30'].append(data_point)\n            elif age <= 40:\n                age_groups['31-40'].append(data_point)\n            elif age <= 50:\n                age_groups['41-50'].append(data_point)\n            elif age <= 60:\n                age_groups['51-60'].append(data_point)\n            else:\n                age_groups['61+'].append(data_point)\n        return age_groups\n\\end{lstlisting}\n\n\n\\subsection{Summary}\nIn this lesson, we explained the concept of object-oriented programming. We started by exploring the motivation behind using custom objects and classes compared to native data types. We've seen how custom objects provide a powerful way to model complex systems, enhance code organization, promote reusability, and encapsulate data and behaviors. We saw how classes can be defined using the class keyword, allowing us to represent real-world concepts like cars and anything else. We also learned how to access and modify the properties of objects created from classes.\n\nThe importance of the self parameter was emphasized as it distinguishes class attributes from other variables in the program. Methods were introduced with a focus on constructors (\\_\\_init\\_\\_) that allow us to set object attributes during creation, and \\_\\_str\\_\\_ method, which customizes the string representation of objects. We also saw how custom methods can be defined within classes to encapsulate specific functionalities.\n\n\n\\subsection{Practical Exercise: OOP based Bus management system [80 mins] }\n\\includegraphics[width=\\textwidth]{Images/video_resource.png} %video A\nThis video shows the final expected output of the exercise.\n\\subsubsection*{part 1: Classes and Objects}\nIn this exercise, we will practice creating and interacting with classes in Python by designing a simple system to manage students and buses. The goal is to create two classes, Student and Bus, each with their respective attributes and methods.\n\n\\begin{itemize}\n    \\item Student Class\n    \\begin{itemize}\n        \\item The Student class represents individual students. It has attributes such as id, first\\_name, and last\\_name.\n        \\item The get\\_student\\_info method returns a formatted string containing the student's information.\n    \\end{itemize}\n    \\item Bus Class\n    \\begin{itemize}\n        \\item The Bus class simulates a bus that can carry students. It has attributes like id, driver, and number\\_of\\_seats.\n        \\item The is\\_bus\\_full method checks if the bus has reached its capacity.\n        \\item The add\\_student method adds a student to the bus if there is available space.\n        \\item The get\\_students method returns a formatted string containing the information of the students on the bus.\n        \\item The get\\_bus\\_info method returns a formatted string summarizing the bus's information, including the driver and the list of students.\n    \\end{itemize}\n\\end{itemize}\n\n\\textbf{Instructions}:\n\\begin{enumerate}\n    \\item Implement the Student class according to the provided attributes and method.\n    \\item Implement the Bus class according to the provided attributes and methods.\n    \\item Create three student instances: s1, s2, and s3, with different information.\n    \\item Create a bus instance b1 with the provided driver name and seat capacity.\n    \\item Print the initial bus information using the get\\_bus\\_info method.\n    \\item Add the students s1, s2, and s3 to the bus using the add\\_student method.\n    \\item Print the updated bus information using the get\\_bus\\_info method.\n\\end{enumerate}\n\nThis exercise will help us practice creating classes, defining attributes, implementing methods, and simulating interactions between objects. It's a practical scenario that showcases how object-oriented programming can be used to model real-world entities and their interactions. Remember, there are always plenty of ways to write the code for any application. Provide a solution for this exercise according to what YOU learned out of the course so far.\n\n\\subsubsection*{part 2: User-Oriented Application}\nIn this second part of the exercise, we will extend our program by creating a Menu class that serves as an interactive user interface for managing students and buses. This class will allow users to perform various actions, such as adding new students, displaying students and buses, creating new buses, and modifying existing buses.\n\n\\textbf{Menu Class:}\n\\begin{itemize}\n\\item The Menu class provides an interactive menu-driven interface for users to interact with the student and bus management system.\n\\item It initializes with empty lists for buses and students.\n\\item The run method displays a menu of options for users and responds to their selections.\n\\item The show\\_all\\_students method displays information about all registered students.\n\\item The show\\_all\\_buses method displays information about all registered buses.\n\\item The new\\_bus method allows users to input information to create a new bus instance and adds it to the list of buses.\n\\item The new\\_student method allows users to input information to create a new student instance and adds it to the list of students.\n\\item The modify\\_a\\_bus method allows users to allocate a student to a specific bus if there is available space.\n\\item The get\\_bus\\_by\\_id and get\\_student\\_by\\_id methods retrieve instances of buses and students based on their IDs.    \n\\end{itemize}\n\n\\textbf{Instructions:}\n\\begin{enumerate}\n    \\item Implement the Menu class with its methods according to the provided code.\n    \\item Create an instance of the Menu class called m.\n    \\item Call the run method on the m instance to start the interactive menu.\n    \\item Users can select options from the menu to add students, display students, create buses, display buses, and modify buses.\n    \\item The program will continue to run until the user chooses to exit (option 0).\n\\end{enumerate}\n\n\\textbf{Potential Interactive Output}:\n\\begin{lstlisting}\n1: new student\n2: show all students\n3: new Bus\n4: show all buses\n5: modify a bus\n0: exit\n----------\nenter your option: 1\nenter id: s1\nenter first name: Alice\nenter last name: Johnson\n1: new student\n2: show all students\n3: new Bus\n4: show all buses\n5: modify a bus\n0: exit\n----------\nenter your option: 1\nenter id: s2\nenter first name: Bob\nenter last name: Smith\n1: new student\n2: show all students\n3: new Bus\n4: show all buses\n5: modify a bus\n0: exit\n----------\nenter your option: 3\nenter id: b1\nenter driver name: John Doe\nenter number of seats: 2\n1: new student\n2: show all students\n3: new Bus\n4: show all buses\n5: modify a bus\n0: exit\n----------\nenter your option: 4\nDisplaying all the buses in the program:\n[1] Driver: John Doe. Students: (no students in this bus yet)\n1: new student\n2: show all students\n3: new Bus\n4: show all buses\n5: modify a bus\n0: exit\n----------\nenter your option: 5\nenter bus id to modify: b1\nyou chose bus: [1] Driver: John Doe. Students: (no students in this bus yet)\nenter the id of the student you want to allocate to this bus: s1\nStudent assigned!\n1: new student\n2: show all students\n3: new Bus\n4: show all buses\n5: modify a bus\n0: exit\n----------\nenter your option: 4\nDisplaying all the buses in the program:\n[1] Driver: John Doe. Students: [s1] Alice Johnson,\n1: new student\n2: show all students\n3: new Bus\n4: show all buses\n5: modify a bus\n0: exit\n----------\nenter your option: 0\nThank you for your time, have a great day!\n\\end{lstlisting}\n\nBy adding the Menu class, you are creating an intuitive way for users to interact with your system. This user-friendly interface will enable users to easily manage and track students and buses within the program. It showcases the practical application of classes, methods, and user input in creating a functional program.\n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]\n\n\n\n\\subsection{Model Answer: OOP based Bus management system}\nBelow are videos discussing the exercise above and showing a potential way to code it.\n\\includegraphics[width=\\textwidth]{Images/video_resource.png} %video B\n\\includegraphics[width=\\textwidth]{Images/video_resource.png} %video C\nYou can also check \\textit{Bus\\_System.ipynb} file and see the code yourself.\n\n\n\\subsection{Activity: Title}\n\\subsubsection*{Your task}\n[short introduction to the activity, followed by a succinct explanation of the task(s)]\n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]", "metadata": {"source": "./full-course/aai.txt"}}}