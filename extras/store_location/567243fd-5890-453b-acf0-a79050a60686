{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"page_content": "{Lesson 3: Iterators [180 mins]}\n\\subsection{Introduction}\nIn this lesson, we will explore iterators and loops in a more advanced way. These powerful tools will enable us to efficiently work with collections of data, making our coding experience much more enjoyable and productive.\n\nJust like how lists helped us organize and manage data, iterators and loops will take our Python skills to the next level. With iterators acting as helpful guides, we'll traverse through elements in collections one by one, accessing and processing information effortlessly. In specific, we will discover the use of the iterators, the for loops with lists, in addition to the break and continue statements.\n\n\n\n\n\\subsection{Introduction to Iterators and Their Role in Python}\n\nIn Python, iterators are an essential and powerful tool that allows us to efficiently work with collections of data. An iterator acts as a handy guide that helps us traverse through elements in a collection one by one, making it easier to access and process information without overwhelming us with technical complexities.\n\nAt the heart of the iterator lies the iterable protocol, consisting of two essential methods: \\textit{\\textbf{iter()}} and \\textit{\\textbf{next()}}. These methods form the foundation for creating objects that can be iterated upon.\n\n\\subsubsection{The Role of Iterators:}\n\\begin{enumerate}\n    \\item \\textbf{Seamless Data Access:} Iterators provide a simple way to access elements in collections (like lists). Iterators allow us to effortlessly explore the data step by step.\n    \\item \\textbf{Memory-Friendly:} With iterators, we don't need to load the entire collection into memory at once. The element is only encountered when needed, making Python an efficient choice for handling large datasets.\n\\end{enumerate}\n\n\\subsection{Understanding the Iterable Protocol}\nIn Python, the Iterable Protocol is a set of rules that an entity or object (for example a list is an entity) follows to allow sequential access to its elements. Think of it as a universal language that different entities can speak to enable iteration.\n\nAn entity that adheres to the Iterable Protocol is called an \"iterable.\" It's like a container that can hold multiple items, and you can access each item one by one without knowing the specifics of how the container stores them.\n\nTo be iterable, an entity must implement one specific method called \\textbf{\\textit{iter()}}. When we want to explore the contents of an iterable, we call this method, and it returns something called an \"iterator\". We use the iterator to navigate through the elements.\n\nThe beauty of the Iterable Protocol lies in its simplicity and generality. Whether it's a list of numbers or a collection of words, as long as it speaks the Iterable Protocol by having the \\textbf{\\textit{iter()}} method, we can use it in a consistent and straightforward manner.\n\n\\subsection{Using the Iter() And Next() Methods}\nIn Python, the \\textbf{\\textit{iter()}} and \\textbf{\\textit{next()}} methods work hand in hand with the Iterable Protocol to help us access elements within an iterable.\n\n\\begin{enumerate}\n    \\item The \\textbf{\\textit{iter()}} method takes an iterable as input and returns an iterator. Remember, an iterator is like a tour guide that leads us through the elements of the iterable. When we call \\textbf{\\textit{iter()}} on an iterable, it prepares the list for iteration, so we can start exploring its elements.\n    \\item The \\textbf{\\textit{next()}} method is used to discover the elements in a list by revealing the next element. It takes the iterator as input and returns the next element in the sequence. With each use of \\textbf{\\textit{next()}}, the iterator advances to the next item in the iterable, allowing us to see one element at a time.\n\\end{enumerate}\n\nLet's say we have a list of numbers: [2, 4, 6, 8, 10]. We can use \\textit{\\textbf{iter()}} to create an iterator for this list. Then, we can use \\textit{\\textbf{next()}} to see each number one by one:\n\n\\begin{lstlisting}[language=Python]\n# Creating an iterator for the list\nnumbers_list = [2, 4, 6, 8, 10]\nnumbers_iterator = iter(numbers_list)\n\n# Accessing elements using next()\nfirst_number = next(numbers_iterator)\nsecond_number = next(numbers_iterator)\nthird_number = next(numbers_iterator)\n\nprint(first_number, second_number, third_number)\n\n# Output: 2 4 6\n\\end{lstlisting}\n\nWith each call to \\textit{\\textbf{next()}}, the iterator advances, giving us the next element in the list. It's like going through the list step by step, revealing each number as we move forward.\n\n\\underline{\\textbf{Note:}} Keep in mind that when there are no more elements to reveal, calling \\textit{\\textbf{next()}} raises a \\textit{\\textbf{StopIteration}} exception (python error). This signals that we've reached the end of the iterator's tour, and there are no more elements to show. We will discuss more about exceptions in other lessons.\n\n\n\\subsection{Exploring For with Lists}\nIn Python, \\textit{for} loops work seamlessly with iterators, offering elegant ways to traverse and process elements within iterables. These loops use iterators to effortlessly navigate through data without the need for manual index management.\n\nThe \\textbf{\\textit{for}} loop is a construct that iterates through elements in an iterable one by one. We explored its basics and how we can iterate for a certain number of iterations previously. In this part, we will focus on how we can iterate a list instead of a sequence. The \\textit{for loop} automatically uses the \\texttt{iter()} method to create an iterator and the \\texttt{next()} method to access elements in each iteration.\n\nIn simpler terms, an iterable is a collection of items that we can loop through, like a list or a string. The \\textbf{\\textit{for}} loop takes each element from the iterable, performs the specified actions, and then moves on to the next element.\n\nLet's take a look at an example of the \\textbf{\\textit{for}} loop in action:\n\n\\begin{lstlisting}[language=Python]\n# Example iterable (list of numbers)\nnumbers_list = [2, 4, 6, 8, 10]\n\n# Using the for loop to access elements\nfor number in numbers_list:\n    print(number)\n\n\\end{lstlisting}\nOutput:\n\\begin{lstlisting}[language=Python]\n2\n4\n6\n8\n10\n\\end{lstlisting}\n In this example, we have a list named numbers\\_list containing five numbers. The \\textbf{\\textit{for}} loop iterates through each element in the list and assigns it to the variable number. Then, it prints the value of number.\n\nWhen you run the code, you will see the numbers 2, 4, 6, 8, and 10 printed one after the other. The \\textbf{\\textit{for}} loop automatically handles the iteration process, making it easy to work with large collections of data.\n\nThe \\textbf{\\textit{for}} loop takes care of creating the iterator and accessing each element, making it a concise and efficient way to work with data in an iterable.\n\n\n\\subsection{Break and Continue}\n\\subsubsection{Break}\nIn Python, the \"break\" statement is a powerful control flow tool that allows you to exit a loop prematurely. It provides a way to terminate the loop's execution even before the loop's natural end, based on a certain condition.\n\nThe \"break\" statement is often used in situations where you need to stop the loop once a specific condition is met, saving unnecessary iterations and improving the efficiency of your code.\n\nLet's illustrate the \"break\" statement with an example:\n\\begin{lstlisting}[language=Python]\n# Example: Finding a specific number in a list\nnumbers_list = [10, 20, 30, 40, 50]\n\n# Let's say we want to find the number 30 in the list\ntarget_number = 30\n\nfor number in numbers_list:\n    if number == target_number:\n        print(\"Found\", target_number, \"in the list.\")\n        break\n\n# Output: Found 30 in the list.\n\\end{lstlisting}\nIn this example, we have a list of numbers. We want to find the number 30 in the list. We use a \"for\" loop to iterate through each number in the list. Inside the loop, we check if the current number matches the target number (30). If it does, we print a message indicating that we found the target number in the list and then use the \"break\" statement to exit the loop prematurely. \\textit{By using the break, we avoid additional useless iterations on the numbers 40 and 50. Sometimes if the list is too big, or if we are using a while loop where we have to wait for a condition to be met, we can use also the break to exit looping.}\n\nNote: As we mentioned earlier, in a for loop, we can write any kind of code we want. For instance, this code can help us in the search process of an element we are looking for in a list. In this example, it is the first time we encountered an if statement inside a loop, which helps us check a specific condition about the element we are looking for. \n\n\\subsubsection{Continue}\nThe \"continue\" statement is used to skip the current iteration of a loop and move on to the next iteration. When the \"continue\" statement is encountered, the remaining code within the loop for the current iteration is skipped, and the loop moves on to the next iteration.\n\nBelow is an example to illustrate the use of the \"continue\" statement.\n\\begin{lstlisting}[language=Python]\n# Example: Printing only even numbers from a list\nnumbers_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nfor number in numbers_list:\n    if number % 2 != 0:\n        continue\n    print(number)\n\n# Output: 2, 4, 6, 8, 10\n\\end{lstlisting}\n\nIn this example, we have a list of numbers. We use a \"for\" loop to iterate through each number in the list. Inside the loop, we check if the number is odd (i.e., not divisible by 2). If it's odd, we use the \"continue\" statement to skip the remaining code for this iteration and move on to the next number in the list. As a result, only the even numbers are printed, and the odd numbers are skipped due to the \"continue\" statement.\n\n% \\subsubsection{Loop Else}\n% In Python, loops can have an \"else\" block, which is executed when the loop completes all iterations without encountering a \"break\" statement. The \"else\" block is optional and provides an elegant way to handle situations where you want to execute additional code after a loop successfully completes its iterations.\n\n% Below is an example illustrating the use of the Loop Else statement:\n% \\begin{lstlisting}[language=Python]\n% # Example: Checking for prime numbers\n% number = 17\n\n% for i in range(2, number):\n%     if number % i == 0:\n%         print(f\"{number} is not a prime number.\")\n%         break\n% else:\n%     print(f\"{number} is a prime number.\")\n\n% # Output: 17 is a prime number.\n% \\end{lstlisting}\n\n% In this example, we check if the number (17 in this case) is a prime number. We use a \"for\" loop that runs from 2 to one less than the number. Inside the loop, we check if the number is divisible by any value of \"i.\" If it is, we print a message indicating that the number is not a prime number and break out of the loop.\n\n% However, if the loop completes all iterations without encountering a \"break\" statement, the \"else\" block is executed, and we print a message stating that the number is a prime number.\n\n\\subsection{Nested For Loop}\nNested loops refer to the concept of having one loop inside another loop. This allows us to perform repeated actions in a hierarchical manner, enabling us to handle more complex data structures and perform operations.\n\nNested loops are particularly useful when we need to work with multidimensional data structures like matrices, perform operations that involve multiple levels of iteration, or search for elements in collections.\n\n\\subsubsection*{Example 1: Searching for Keys in a List of Objects}\n\\begin{lstlisting}[language=Python]\nitems = [10, 20, [4, 5], 30.5, 40] # A set of objects\ntests = [[4, 5], [7, 8]] # Keys to search for\n\nfor key in tests: # For all keys\n    for item in items: # For all items\n        if item == key: # Check for match\n            print(key, \"was found\")\n            break\n    else:\n        print(key, \"not found!\")\n\\end{lstlisting}\nIn this example, we have a list of elements called \"items,\" which includes numbers and a key. We also have a list of lists called \"tests,\" representing the keys we want to search for. We use nested loops to perform the search. The outer loop iterates through each list in the \"tests\" list, and the inner loop iterates through each item in the \"items\" list for each key.\n\nFor each key, we check if there is a matching key in the \"items\" list. If a match is found, we print a message indicating that the key was found, and then we use the \"break\" statement to exit the inner loop prematurely. If the inner loop completes all iterations without finding a match, the loop's \"else\" clause is executed, and we print a message stating that the key was not found.\n\nOutput:\n\\begin{lstlisting}[language=Python]\n[4, 5] was found\n[7, 8] not found!\n\\end{lstlisting}\n\n% \\subsubsection*{Example 2: Collecting Common Items in Two Lists}\n% In this example, we perform a typical data-structure task using a nested loop to collect common items in two lists. We aim to find the common elements between \"list1\" and \"list2\" and store them in the \"common\\_elements\" list.\n\n% \\begin{lstlisting}[language=Python]\n% list1 = [1, 3, 5, 7, 9]\n% list2 = [2, 3, 5, 8, 10]\n\n% common_elements = [] # Start empty\n\n% for x in list1: # Scan first list\n%     if x in list2: # Common item?\n%         common_elements.append(x) # Add to result list\n% \\end{lstlisting}\n% In this example, we have two lists, \"list1\" and \"list2,\" containing numbers. We use a nested loop where the outer loop iterates through each element in \"list1,\" and the inner loop checks if that element is present in \"list2.\" If a common element is found, we add it to the \"common\\_elements\" list.\n\n% After the loop completes, the \"common\\_elements\" list will contain all the elements that are common to both \"list1\" and \"list2.\"\n\n% Output:\n% \\begin{lstlisting}[language=Python]\n% [3, 5]\n% \\end{lstlisting}\n\nNested loops are powerful tools for handling complex data structures and performing tasks that require multiple levels of iteration. However, it's essential to be cautious with nested loops, as they can result in a high number of iterations, leading to potential performance issues with large data sets.\n\n\\subsection{Summary}\nIn this lesson, we explored iterators and loops in Python. Iterators allowed us to traverse collections of data efficiently. Using the \\textbf{\\textit{iter()}} and \\textbf{\\textit{next()}} methods, we accessed elements one by one, making data processing memory-friendly.\n\nThe \\textbf{\\textit{for}} loop provided a concise way to iterate through elements. Nested loops handled complex data structures and tasks requiring multiple iterations. With \\textbf{\\textit{break}} and \\textbf{\\textit{continue}} statements, we controlled loop flow, making our code efficient.\n\n\\subsection{Practical Exercise: Using Iterators and Loops [30 mins]}\n\\subsubsection*{Your task}\nIn this set of exercises, we will practice using loops and iterators in Python. We will work on tasks that involve calculating sums of even numbers, generating the Fibonacci sequence, transposing matrices, and finding prime numbers. \n\n\\textbf{\\textit{Exercise 1: Exploring Iterators with a List}}\nIn this exercise, we will practice using iterators to explore a list of numbers. Iterators will help us access and process each element in the list, one at a time.\n\n\\textbf{Tasks:} \n\\begin{enumerate}\n    \\item Create a list containing the numbers: 10, 20, 30, 40, 50.\n    \\item Use a \\textbf{\\textit{for}} loop and an iterator to print each number in the list on a new line.\n\\end{enumerate}\n\n\\textbf{\\textit{Exercise 2: Searching for Elements}}\nNow that we know how to use \\textbf{\\textit{for}} loops, let's try searching for specific elements in a list.\n\\textbf{Tasks:}\n\\begin{enumerate}\n    \\item Create a list containing the words: \"apple\", \"banana\", \"orange\", \"grapes\", \"mango\".\n    \\item Use a \\textbf{\\textit{for}} loop to check if \"orange\" is present in the list.\n    \\item If \"orange\" is found, print \"Found 'orange' in the list.\" Otherwise, print \"Sorry, 'orange' not found.\"\n\\end{enumerate}\n\n% \\textbf{\\textit{Exercise 3: Exploring the \\textbf{\\textit{while}} Loop}}\n% Now, let's practice using the \\textbf{\\textit{while}} loop to iterate through a list and access its elements.\n% \\textbf{Tasks:}\n% \\begin{enumerate}\n%     \\item Create a list containing the numbers: 5, 10, 15, 20, 25.\n%     \\item Create an iterator for the list using the \\textbf{\\textit{iter()}} function.\n%     \\item Use a \\textbf{\\textit{while}} loop to print each number in the list on a new line.\n% \\end{enumerate}\n\n\\textbf{\\textit{Exercise 3: Nested Loops}}\nNested loops allow us to perform tasks that involve multiple iterations. Let's practice using nested loops to find common elements in two lists.\n\n\\textbf{Tasks:}\n\\begin{enumerate}\n    \\item Create two lists:\n    \\begin{itemize}\n        \\item List 1: 1, 2, 3, 4, 5\n        \\item List 2: 4, 5, 6, 7, 8\n    \\end{itemize}\n    \\item Use nested \\textbf{\\textit{for}} loops to find and print common elements present in both lists.\n\\end{enumerate}\n\n\\textbf{\\textit{Exercise 4: Skip Odd Numbers}}\nWe can use the \\textbf{\\textit{continue}} statement to skip specific elements in a loop. Let's practice using it to print only even numbers from a list.\n\n\\textbf{Tasks:}\n\\begin{enumerate}\n    \\item Create a list containing numbers: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10.\n    \\item Use a \\textbf{\\textit{for}} loop and the \\textbf{\\textit{continue}} statement to print only even numbers from the list on separate lines.\n\\end{enumerate}\n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]\n\n\\subsection{Model Answer(s): Using Iterators and Loops}\n\\textbf{\\textit{Exercise 1: Exploring Iterators with a List}}\n\\begin{lstlisting}[language=Python]\n# Create a list of numbers\nnumbers_list = [10, 20, 30, 40, 50]\n\n# Use a for loop to print each number\nfor number in numbers_list:\n    print(number)\n\\end{lstlisting}\n\n\\textbf{\\textit{Exercise 2: Searching for Elements}}\n\\begin{lstlisting}[language=Python]\n# Create a list of words\nfruits_list = [\"apple\", \"banana\", \"orange\", \"grapes\", \"mango\"]\n\n# Use a for loop to search for \"orange\"\nfound = False\nfor fruit in fruits_list:\n    if fruit == \"orange\":\n        found = True\n        break\n\nif found:\n    print(\"Found 'orange' in the list.\")\nelse:\n    print(\"Sorry, 'orange' not found.\")\n\\end{lstlisting}\n\n% \\textbf{\\textit{Exercise 3: Exploring the \\textbf{\\textit{while}} Loop}}\n% \\begin{lstlisting}[language=Python]\n% # Create a list of numbers\n% numbers_list = [5, 10, 15, 20, 25]\n\n% # Create an iterator for the list\n% numbers_iterator = iter(numbers_list)\n\n% # Use a while loop to print each number\n% while True:\n%     try:\n%         number = next(numbers_iterator)\n%         print(number)\n%     except StopIteration:\n%         break\n% \\end{lstlisting}\n\n\\textbf{\\textit{Exercise 3: Nested Loops}}\n\\begin{lstlisting}[language=Python]\n# Create two lists\nlist1 = [1, 2, 3, 4, 5]\nlist2 = [4, 5, 6, 7, 8]\n\n# Use nested for loops to find common elements\nfor number1 in list1:\n    for number2 in list2:\n        if number1 == number2:\n            print(number1)\n\\end{lstlisting}\n\n\\textbf{\\textit{Exercise 4: Skip Odd Numbers}}\n\\begin{lstlisting}[language=Python]\n# Create a list of numbers\nnumbers_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n# Use a for loop to print only even numbers\nfor number in numbers_list:\n    if number % 2 != 0:  # Skip odd numbers\n        continue\n    print(number)\n\\end{lstlisting}\n\n\\subsection{Share and Compare: Using Iterators and Loops [30 mins]}\n\\subsubsection*{Your task}\nNow it's time to share your solutions and compare them with your fellow learners. Sharing your code and discussing different approaches can help you gain new insights and learn from each other.\n\nFeel free to share your code, ask questions, and explore the solutions of others. \n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]", "metadata": {"source": "./full-course/aai.txt"}}}