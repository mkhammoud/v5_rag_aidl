{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"page_content": "{Lesson 1: Introduction to Numpy  [360 mins]}\n\\subsection{Introduction}\nWelcome to this lesson on NumPy! NumPy is an important tool for working with data in Python, especially when performing exploratory data analysis. Knowing how to handle and analyze data is super useful when building AI solutions. NumPy makes tasks like math operations and data manipulation much easier. It's a great starting point to get into data analysis. \n\nIn this lesson, we will cover the fundamentals of NumPy, starting with its role in scientific computing. We'll explore how to create NumPy arrays, understand their basic attributes, and learn various techniques for indexing, slicing, reshaping, concatenating, and splitting arrays. Then, we'll dive into performing computations on arrays, including arithmetic operations and working with absolute values. Next, we'll explore some statistical concepts and how to apply them on a dataset using numpy, including the mean, standard deviation,a nd variance. We'll introduce broadcasting, an essential tool for performing operations on arrays with different shapes. We'll also discuss comparisons, masking, and boolean logic, with practical examples using a dataset.\n\nAfter this lesson, we'll be well-prepared to tackle more advanced topics and even learn about Pandas, another useful tool for working with data. Let's get started!\n\n\\subsection{Numpy and Its Role in Scientific Computing}\nAs AI programmers, we need to work with a lot of data, like numbers or measurements. Python, a popular programming language, gives us some basic tools to handle data, like using lists or arrays from its built-in 'array' module.\n\nFor example, we can use 'array' to make a list of numbers and store them efficiently. But there's something even better for our work: NumPy! NumPy is like a supercharged version of 'array.' It not only helps us store data efficiently but also makes it easier to do different sorts of calculations and operations with that data.\n\nLet's break down the advantage of using NumPy over lists or the built-in 'array':\n\n\\begin{itemize}\n    \\item \\textbf{Efficient Data Storage:} Both Python's 'array' and NumPy help us store data, but NumPy does it even better. It's like having a super-efficient storage system for all our numbers and measurements.\n    \\item \\textbf{Powerful Operations:} NumPy doesn't stop at storage; it's like a magic toolbox that comes with tons of tools for doing math and science. Want to add, subtract, or multiply a bunch of numbers? NumPy can do it quickly and easily.\n    \\item \\textbf{Simplified Coding:} NumPy makes our code cleaner and shorter because it's designed specifically for scientific computing and AI tasks. We won't have to write long, complex code to work with data anymore.\n    \\item \\textbf{Standard Practice:} In the world of scientific computing and AI, NumPy is like a standard language that everyone understands. When we use NumPy, our work becomes more accessible to others, and we can easily collaborate with fellow scientists and programmers.\n\\end{itemize}\n\nSo, when we're building AI models, NumPy is a great choice. It simplifies our work, makes it more efficient, and helps us achieve better results. \n\nNow, we will start with the simply numpy import statement in Python:\n\n\\begin{lstlisting}[language=Python]\nimport numpy as np\n\\end{lstlisting}\n\n\\textbf{\\textit{Note}} that \\textit{np} in this import statement is an alias for numpy, thus we can use \\textit{np} instead of writing \\textit{numpy} in our code.\n\n\\subsection{Creating Numpy Arrays}\n\\subsubsection{Creating Numpy Arrays From Lists}\nWe can use a cool tool called \\textbf{\\textit{np.array}} to create arrays from regular Python lists. Imagine we have a list of numbers, and we want to turn it into a powerful NumPy array. Here's how we can do it:\n\\begin{lstlisting}[language=Python]\nimport numpy as np\n\n# Let's make a simple integer array\nsimple_array = np.array([1, 4, 2, 5, 3])\nprint(simple_array)\n# Output: [1. 4. 2. 5. 3.]\n\\end{lstlisting}\n\nBut here's a thing to remember: unlike Python lists, NumPy wants all the data inside an array to be of the same type. If they're not, NumPy will try to be smart and make everything the same type (usually floating-point numbers):\n\\begin{lstlisting}[language=Python]\nmixed_array = np.array([3.14, 4, 2, 3])\nprint(mixed_array)\n\n#Output: [3.14 4.   2.   3.  ]\n\\end{lstlisting}\n\nIf we want to be specific about the data type, we can tell NumPy by using the dtype keyword:\n\\begin{lstlisting}[language=Python]\nspecific_array = np.array([1, 2, 3, 4], dtype='int')\nprint(specific_array)\n# Output: [1 2 3 4]\n\\end{lstlisting}\n\nAnd guess what? NumPy is not just about 1D arrays; it can handle multidimensional arrays too. Imagine creating a 2D array with rows and columns, like a table:\n\\begin{lstlisting}[language=Python]\ntable_array = np.array([range(i, i + 3) for i in [2, 4, 6]])\nprint(table_array)\n# Output:\n# [[2 3 4]\n#  [4 5 6]\n#  [6 7 8]]\n\\end{lstlisting}\n\nIt is the first time we see this programming style in Python, which we refer to as list comprehension. In this code, we are creating a new list by applying an expression to each item in an iterable while collecting the results in a list.\\\\\nOn the right side of the \\textit{for}, we have the loop condition, while on the left side is the expression applied. \\textit{range(i, i+3)} is an object representing a sequence of numbers: from \\textit{i} to \\textit{i + 3}. Thus, \\textit{[range(i, i+3) for i in [2, 4, 6]]} returns a two-dimensional list where each row contains a list of three elements incremented by one, starting with an element from the list [2, 4, 6].\\\\\nAfterward, we apply np.array() on the resulting list to convert it to a numpy array.\n\n\\subsubsection{Creating Arrays from Scratch}\nNow, let's talk about making arrays from scratch, which can be handy, especially when we need bigger arrays.\n\nCreating an array filled with zeros:\n\n\\begin{lstlisting}[language=Python]\nzero_array = np.zeros(10, dtype=int)\nprint(zero_array)\n# Output: [0 0 0 0 0 0 0 0 0 0]\n\\end{lstlisting}\n\n10 as an argument to np.zeros() refers to desired size of the array. Thus, we get an array containing ten zeros.\n\nMaking an array filled with ones:\n\\begin{lstlisting}[language=Python]\nones_array = np.ones((3, 5), dtype=float)\nprint(ones_array)\n# Output:\n# [[1. 1. 1. 1. 1.]\n#  [1. 1. 1. 1. 1.]\n#  [1. 1. 1. 1. 1.]]\n\\end{lstlisting}\n\n(3, 5) as an argume to the np.ones() function refers to ultimate shape of the output array. Thus, we get as an output a two-dimensional array with three rows and five columns filled with ones.\n\nCreating an array with a specific number:\n\\begin{lstlisting}[language=Python]\nspecific_number_array = np.full((3, 5), 3.14)\nprint(specific_number_array)\n# Output:\n# [[3.14 3.14 3.14 3.14 3.14]\n#  [3.14 3.14 3.14 3.14 3.14]\n#  [3.14 3.14 3.14 3.14 3.14]]\n\\end{lstlisting}\n\nGenerating a sequence of numbers:\n\n\\begin{lstlisting}[language=Python]\nsequence_array = np.arange(0, 20, 2)\nprint(sequence_array)\n# Output: [ 0  2  4  6  8 10 12 14 16 18]\n\\end{lstlisting}\n\nIn this code, we pass 0, 20, and 2 as parameters to the np.arange() function. 0 refers to the starting number of the sequence. 20 is the maximum number that we should exclude from the sequnce. 2 is the number of steps taken for each number generated in the sequence. Thus, the output contains a NumPy array with a sequence starting from 0 all the way to 18 with an addition of 2 for every element.\n\nAnd there we have it! NumPy helps us create arrays from our data or from scratch, making it easier to work with numbers in Python.\n\n\\textit{Remember, you only learn coding by practice and not only reading. Open a notebook instance and let's practice NumPy together for the rest of the lesson!}\n\n\\subsection{The Basics of Numpy Arrays}\nData manipulation in Python is often associated with NumPy array manipulation. Several Python tools for data manipulation, such as Pandas (covered in the next lesson), are built on top of NumPy. In this part of our lesson, we discover several examples for accessing elements, subarrays, split, reshape, and join arrays. \n\n\\begin{itemize}\n    \\item Attributes: Size, shape, and datatypes of the array\n    \\item Indexing: Reading and writing to a location in the array\n    \\item Slicing: Reading and writing a subarray\n    \\item Reshaping: Changing the dimensions of the array\n    \\item Joining \\& Splitting: Merging arrays into one or splitting one into many\n\\end{itemize}\n\n\\subsubsection{Numpy Array Attributes}\nLet's start exploring some useful attributes of numpy arrays by starting with the below example:\n\\begin{lstlisting}[language=Python]\n# Importing the NumPy library\nimport numpy as np\n\n# Creating three random arrays\nx1 = np.random.randint(10, size=6)  # One-dimensional array\nx2 = np.random.randint(10, size=(3, 4))  # Two-dimensional array\nx3 = np.random.randint(10, size=(3, 4, 5))  # Three-dimensional array\n\\end{lstlisting}\n\nIn this example, we are creating three numpy arrays with one, two, and three dimensions respectively. As we can see we use np.random.randint to fill the array with random integer numbers. We specify the size of the array by passing size=dimensions (i.e size=(3, 4) for a 2D array of size 3 by 4).\n\nNote that when we want to call attributes on an Object, we don't use paranthese, otherwise it becomes a function call (Reminder from Week \\#5). Now let's explore some essential attributes of these arrays:\n\n\\begin{itemize}\n    \\item .\\textbf{ndim} attributes tells us the number of dimensions in the array. In this case, x3 is a three-dimensional array. Here is an example\n\n    \\begin{lstlisting}[language=Python]\n    print(x1.ndim)\n    print(x2.ndim)\n    print(x3.ndim)\n    \\end{lstlisting}\n\n    The output is:\n    \\begin{lstlisting}[language=Python]\n    1\n    2\n    3\n    \\end{lstlisting}\n    \\item \\textbf{.shape} is another attribute that gives us the size of each dimension. The shape of x3 is (3, 4, 5), meaning it has three dimensions with sizes 3, 4, and 5. Below is an example:\n    \n    \\begin{lstlisting}[language=Python]\n    print(x1.shape)\n    print(x2.shape)\n    print(x3.shape)\n    \\end{lstlisting}\n\n    The output becomes:\n    \\begin{lstlisting}[language=Python]\n    (6,)\n    (3, 4)\n    (3, 4, 5)\n    \\end{lstlisting}\n    \\item \\textbf{.size} provides the total size of the array. For x3, the size is 60, which is the product of the dimensions (3 * 4 * 5). Let us take an example:\n\n    \\begin{lstlisting}[language=Python]\n    print(x1.size)\n    print(x2.size)\n    print(x3.size)\n    \\end{lstlisting}\n\n    The output would be:\n    \\begin{lstlisting}[language=Python]\n    6\n    12\n    60\n    \\end{lstlisting}\n\\end{itemize}\n\n\\subsubsection{Numpy Array Indexing}\nIn Week\\#3, we have done some good practice on lists indexing and slicing. Now in NumPy, indexing and slicing is quite similar, so you should find it familiar. Similar to lists for one-dimensional arrays, we use square brackets with an integer value in between to refer to an element in the array at a specific index. \n\n\\begin{lstlisting}[language=Python]\n# Example with a one-dimensional array\nx1 = np.array([5, 0, 3, 3, 7, 9])\nx1[0]  # Access the first element (index 0)\n# Output: 5\nx1[4]  # Access the fifth element (index 4)\n# Output: 7\n\\end{lstlisting}\n\nSimilar to lists, you can also use negative indices to count from the end of the array:\n\n\\begin{lstlisting}[language=Python]\nx1[-1]  # Access the last element\n# Output: 9\nx1[-2]  # Access the second-to-last element\n# Output: 7\n\\end{lstlisting}\n\nIn multidimensional arrays, you access elements by specifying indices separated by comma:\n\\begin{lstlisting}[language=Python]\n# Example with a two-dimensional array\nx2 = np.array([[3, 5, 2, 4],\n              [7, 6, 8, 8],\n              [1, 6, 7, 7]])\n\nx2[0, 0]  # Access the element at the first row, first column\n# Output: 3\nx2[2, 0]  # Access the element at the third row, first column\n# Output: 1\nx2[2, -1]  # Access the element at the third row, last column\n# Output: 7\n\\end{lstlisting}\n\nTo modify values in the array, we can use the same notation. Here is an example:\n\\begin{lstlisting}[language=Python]\nx2[0, 0] = 12  # Modify the element at the first row, first column\nx2\n# Output: \n# array([[12, 5, 2, 4],\n#        [7, 6, 8, 8],\n#        [1, 6, 7, 7]])\n\\end{lstlisting}\n\n\\textit{It's essential to note that NumPy arrays have a fixed data type, unlike Python lists}. If we attempt to insert a value of a different data type into an array, the value will be silently truncated. For example, if we add a float number to an integer array, we float number becomes an integer, thus the decimal point values are removed. So, be aware of this behavior when working with NumPy arrays:\n\n\\begin{lstlisting}[language=Python]\nx1[0] = 3.14159  # Attempting to insert a float into an integer array (truncated)\nx1\n# Output: array([3, 0, 3, 3, 7, 9])\n\\end{lstlisting}\n\nThis was a nice reminder to how we can access and update elements in lists but on NumPy arrays instead. We now know that one of the main differences between lists and NumPy is that NumPy have a fixes type.\n\n\\subsubsection{Slicing a Numpy Array}\nSimilar to lists, we also using square brackets with numbers divided by a column (:) to access or update a subarray in NumPy: \\textit{x[start:stop:step]} where x is the array. But still, there are some important differences to consider between subarrays in Lists v.s. NumPy. \n\n\\subsubsection*{One-dimensional Subarrays:}\nLet's start with one-dimensional arrays. Here's how you can access subarrays using slices:\n\n\\begin{lstlisting}[language=Python]\n# Example with a one-dimensional array\nx = np.arange(10)\nx[:5]  # Access the first five elements\n# Output: array([0, 1, 2, 3, 4])\nx[5:]  # Access elements after index 5\n# Output: array([5, 6, 7, 8, 9])\nx[4:7]  # Access a middle subarray\n# Output: array([4, 5, 6])\n\nx[::2]  # Access every other element\n# Output: array([0, 2, 4, 6, 8])\nx[1::2]  # Access every other element, starting at index 1\n# Output: array([1, 3, 5, 7, 9])\n\n# Reversing an array\nx[::-1]  # Access all elements in reverse order\n# Output: array([9, 8, 7, 6, 5, 4, 3, 2, 1, 0])\nx[5::-2]  # Access every other element in reverse order, starting at index 5\n# Output: array([5, 3, 1])\n\\end{lstlisting}\n\n\\subsubsection*{Multi-dimensional Subarrays:}\nMultidimensional array slicing works similarly, using multiple slices separated by commas:\n\\begin{lstlisting}[language=Python]\n# Example with a two-dimensional array\nx2 = np.array([[12, 5, 2, 4],\n               [7, 6, 8, 8],\n               [1, 6, 7, 7]])\n\nx2[:2, :3]  # Access two rows and three columns\n# Output: \n# array([[12, 5, 2],\n#        [7, 6, 8]])\n\nx2[:3, ::2]  # Access all rows and every other column\n# Output: \n# array([[12, 2],\n#        [7, 8],\n#        [1, 7])\n\n# Reversing subarray dimensions\nx2[::-1, ::-1]\n# Output: \n# array([[7, 7, 6, 1],\n#        [8, 8, 6, 7],\n#        [4, 2, 5, 12])\n\\end{lstlisting}\n\n\\subsubsection*{Accessing Rows and Columns:}\nWe can access individual rows and columns using indexing and slicing. To access a single column, use \\textit{x2[:, 0]}, and for a row, use \\textit{x2[0, :]}. We can omit the empty slice for row access, making it more concise: \\textit{x2[0]}.\n\n\\subsubsection*{Subarrays as Views:}\nWhen we create subarrays using slicing, it's important to note that NumPy returns views, not copies of the data. This means modifying a subarray will change the original array.\n\\begin{lstlisting}[language=Python]\nx2_sub = x2[:2, :2]\nx2_sub[0, 0] = 99  # Modifying the subarray\n\\end{lstlisting}\nThis results in \\textit{x2} being changed by updating the element at index 0, 0 to 99. Thus, if we print \\textit{x}, we get the following\n\\begin{lstlisting}[language=Python]\narray([[99,  5,  2,  4],\n       [ 7,  6,  8,  8],\n       [ 1,  6,  7,  7]])\n\\end{lstlisting}\n\n\\subsubsection*{Creating Copies of Arrays:}\nKnowing that Numpy returns views when trying to access subarrays, it is sometimes useful to create an independent copy of the array, thus avoiding any modification to the original one. To achieve this, we use the \\textit{copy()} method on the numpy array object. Here is an example:\n\\begin{lstlisting}[language=Python]\n# Create a NumPy array\noriginal_array = np.array([1, 2, 3, 4, 5])\n\n# Create a copy of the original array\ncopied_array = original_array.copy()\n\n# Modify the copied array\ncopied_array[0] = 99\n\n# Check the original and copied arrays\nprint(\"Original Array:\", original_array)\nprint(\"Copied Array:\", copied_array)\n\\end{lstlisting}\n\nIn this example, we create a copy from the \\textit{original\\_array} using the \\textit{copy()} function. updating the \\textit{copied\\_array} does not update the original one. Below is the expected output:\n\\begin{lstlisting}[language=Python]\nOriginal Array: [1 2 3 4 5]\nCopied Array: [99  2  3  4  5]\n\\end{lstlisting}\n\n\\subsubsection{Reshaping a Numpy Array}\nWe can easily transform data into a format that's suitable for our specific analysis or algorithm. For instance, we can reshape data into a matrix (2D array) to perform matrix operations, or we can change the data shape to match the input requirements of a machine learning model. Here is an example on how it can be done:\n\\begin{lstlisting}[language=Python]\n# Create a one-dimensional array\noriginal_array = np.array([1, 2, 3, 4, 5, 6, 7, 8])\n\n# Reshape the one-dimensional array into a two-dimensional array (2 rows, 4 columns)\nreshaped_array = original_array.reshape(2, 4)\n\n# Print the original and reshaped arrays\nprint(\"Original Array:\")\nprint(original_array)\n\nprint(\"\\nReshaped Array:\")\nprint(reshaped_array)\n\\end{lstlisting}\nIn this code example, we create an array of shape \\textit{(8, )} containing eight elements. We create a reshaped array with a desired shape of \\textit{(2, 4)}. Thus, the obtained array should be two-dimensional containing two rows and four columns. Let's verify this by checking the output of our program:\n\\begin{lstlisting}[language=Python]\nOriginal Array:\n[1 2 3 4 5 6 7 8]\n\nReshaped Array:\n[[1 2 3 4]\n [5 6 7 8]]\n\\end{lstlisting}\n\n\\subsubsection{Numpy Concatenation and Splitting}\nAssume that we have two arrays that we need to append to each other, we can use \\textit{np.concatenate()}. In addition, having a single array, trying to split it into two numpy arrays is another powerful skill. We can use \\textit{np.split()} to split a numpy array into two. Numpy array concatenation and split skills are handful when performing some data processing. Let us take some simple examples:\n\n\\begin{lstlisting}[language=Python]\n# Example of concatenating two one-dimensional arrays\narray1 = np.array([1, 2, 3])\narray2 = np.array([4, 5, 6])\n\nresult = np.concatenate((array1, array2))\n\nprint(\"Concatenated Array:\")\nprint(result)\n\\end{lstlisting}\nIn this example, \\textit{array1} and \\textit{array2} are concatenated, creating a new one-dimensional array. Notice that the function \\textit{np.concatenate()} take a tupe of the two NumPy arrays as a parameter, resulting in the combined array. The result will be \\textit{[1, 2, 3, 4, 5, 6]}.\n\nNow let's take an example on how we can split a NumPy array:\n\\begin{lstlisting}[language=Python]\nimport numpy as np\n\n# Example of splitting a one-dimensional array\noriginal_array = np.array([1, 2, 3, 4, 5, 6])\n\n# Split the array into two equal parts\nsplit_arrays = np.split(original_array, 2)\n\nprint(\"Split Arrays:\")\nprint(split_arrays)\n\\end{lstlisting}\n\nIn this example, \\textit{original\\_array} is split into two equal parts. Notice that the split function takes as a parameter a NumPy array in addition to an integer, indicating the number of resulting arrays. The result is a list of two one-dimensional arrays: \\textit{[array([1, 2, 3]) array([4, 5, 6])]}.\n\n\n\\subsection{Computation on Numpy Arrays}\n% We don't have to worry for now about the mechanism underlyin NumPy's implementation, but what we have to know is that NumPy uses UFuncs, which makes operations on arrays in Python much faster compared to using traditional loops for isntance. In particular, instead of looping over an entier array and initializing its values randomly, we can do this using NumPy in one line and at a much faster time to execute.\n\nWe don't need to concern ourselves with the underlying details of NumPy's inner workings at this stage. What's essential to understand is that NumPy employs Universal Functions (UFuncs), which significantly enhance the speed and efficiency of array operations in Python when compared to using traditional loops, for example.\n\nWith NumPy, we can perform operations on arrays more efficiently and concisely. Instead of manually iterating over the entire array and setting its values, we can achieve the same task with a single line of code. This not only simplifies the code but also reduces execution time, making our computations much faster and more efficient.\n\nIn this part of our lesson, we will be exploring a variety of NumPy functions that can help us in our data analysis and processing stages. In particular, we will touch on the following NumPy functionalities:\n\n\\subsubsection{Arithmetic Operations:}\nIn NumPy, Universal Functions (UFuncs) offer a natural and intuitive way to perform operations on arrays. They take advantage of Python's familiar arithmetic operators, such as addition, subtraction, multiplication, and division. This makes working with NumPy arrays straightforward and convenient:\n\\begin{lstlisting}[language=Python]\nx = np.arange(4)\nprint(\"x =\", x)\nprint(\"x + 5 =\", x + 5)\nprint(\"x - 5 =\", x - 5)\nprint(\"x * 2 =\", x * 2)\nprint(\"x / 2 =\", x / 2)\nprint(\"x // 2 =\", x // 2)  # Floor division\n\\end{lstlisting}\n\nThe output of the program is:\n\\begin{lstlisting}[language=Python]\n# x = [0 1 2 3]\n# x + 5 = [5 6 7 8]\n# x - 5 = [-5 -4 -3 -2]\n# x * 2 = [0 2 4 6]\n# x / 2 = [0.  0.5 1.  1.5]\n# x // 2 = [0 0 1 1]\n\\end{lstlisting}\n\nAll these arithmetic operations are essentially convenient wrappers around specific NumPy functions. For example, the + operator is a wrapper for the np.add function:\n\\begin{lstlisting}[language=Python]\nnp.add(x, 2)\n# Output: array([2, 3, 4, 5])\n\\end{lstlisting}\n\nHere's a list of common arithmetic operations and their corresponding UFuncs:\n\\begin{itemize}\n    \\item $+  \\rightarrow$ \\textit{np.add} (Addition)\n    \\item $-  \\rightarrow$ \\textit{np.subtract} (Subtraction)\n    \\item $- \\rightarrow$ \\textit{np.negative} (Unary negation)\n    \\item $* \\rightarrow$ \\textit{np.multiply} (Multiplication)\n    \\item $/ \\rightarrow$ \\textit{np.divide} (Division)\n    \\item $// \\rightarrow$ \\textit{np.floor\\_divide} (Floor division)\n    \\item $** \\rightarrow$ \\textit{np.power} (Exponentiation)\n% \u2192 np.mod (Modulus/remainder)\n\\end{itemize}\n\nNumPy makes it easier to use the mathematical operation signs instead of writing the whole function.\n\n\\subsubsection{Absolute Value}\nNumPy also understands Python's built-in absolute value function. You can use abs(x) to compute the absolute value of a NumPy array (Converting all negative values to positive values):\n\\begin{lstlisting}[language=Python]\nx = np.array([-2, -1, 0, 1, 2])\nbp.abs(x)\n# Output: array([2, 1, 0, 1, 2])\n\\end{lstlisting}\nUsing \\textit{np.abs()} on the array \\textit{x} leads to converting all of its integers to positive numbers. Notice that when using NumPy's UFunc, we don't have to loop over the elements of the array.\n\n\\subsubsection{Learning More}\nIf you feel like you want to learn more about UFuncs and their different features, you can always read the documentation on the NumPy website at:\\\\ https://numpy.org/doc/stable/reference/ufuncs.html\n\n\\subsection{Min, Max, and Everything In Between}\nUnderstanding and mastering essential NumPy functions like min, max, sum, mean, variance, and standard deviation is not only a valuable skill but a fundamental building block for anyone working with data in Python. Don't worry if you have not seen some of the mathematical terms before, we will break them down in simple terms in this lesson. It is very important to know that these functions enable us to efficiently analyze, manipulate, and gain deeper insights from our data, making them essential in various domains, including machine learning. Let's explore these functions one by one with coding examples to see why they are so important.\n\n\\begin{itemize}\n    \\item \\textbf{Min \\& Max}: \"min\" is the minimum value in the array, while \"max\" refers to the maximum value. These functions are essential for understanding the range of your data and identifying extreme values. Below is an example of how to get the \"min\" \\& \"max\" in a NumPy array:\n    \\begin{lstlisting}[language=Python]\n        import numpy as np\n\n        data = np.array([10, 7, 15, 3, 22, 5])\n        minimum = np.min(data)\n        maximum = np.max(data)\n        \n        print(\"Minimum:\", minimum)\n        print(\"Maximum:\", maximum)\n\n        # Output\n\n        # Minimum: 3\n        # Maximum: 22\n    \\end{lstlisting}\n    \n    \\item \\textbf{Sum:} The \"sum\" is used to compute the sum of all elements in an array. This use of the \"sum\" function in numpy becomes handy in various mathematical and data analysis tasks, helping you find totals, averages, and aggregates, and ensuring the completeness and correctness of data and calculations. Let's take an example:\n    \\begin{lstlisting}[language=Python]\n        import numpy as np\n\n        sales = np.array([350, 420, 270, 180, 510])\n        total_sales = np.sum(sales)\n        \n        print(\"Total Sales:\", total_sales)\n        \n        # Output\n\n        # Total Sales: 1730\n    \\end{lstlisting}\n    \n    \\item \\textbf{Mean:} The \"mean\" is like finding the middle or typical value in a set of numbers. Imagine you have a list of test scores: 85, 92, 78, 96, and 88. The mean is like asking, \"What's the score that's right in the middle?\" In this case, it's 87.8. We need the mean because it helps us understand what's normal or typical in a set of numbers. It's like finding the center of the data. Here is an example:\n    \\begin{lstlisting}[language=Python]\n        import numpy as np\n        scores = np.array([85, 92, 78, 96, 88])\n        average = np.mean(scores)\n        \n        print(\"Average Score:\", average)\n        \n        # Output\n        \n        # Average Score: 87.8\n    \\end{lstlisting}\n    \\item \\textbf{Standard Deviation:} Standard deviation (\"std\" function in NumPy) is a simple number that describes how spread out the numbers are. For instance, in a class with similar test scores, the standard deviation is low. If scores are all over the map, it's high. Standard deviation is a quick way to understand how much the data \"scatters.\" It helps us see if the data is tightly packed or spread out, which is crucial when trying to understand the data we are dealing with. Below is an example wiht NumPy:\n    \\begin{lstlisting}[language=Python]\n        import numpy as np\n\n        data = np.array([12, 15, 10, 18, 14])\n        std_deviation = np.std(data)\n        \n        print(\"Standard Deviation:\", std_deviation)\n\n        # Output\n        \n        # Standard Deviation: 2.7129319932501073\n    \\end{lstlisting}\n    \n    \\item \\textbf{Variance:} is a measure of how spread out or different the numbers are from the mean. For example, if we wanted to identify any students with exceptionally high or low scores, we might look at the variance to see how much the scores deviate from the mean. Variance is important because it tells us how consistent or varied the data is. This helps us see if data is stable or changing. Let's consider the below example:\n    \\begin{lstlisting}[language=Python]\n    import numpy as np\n\n    data = np.array([12, 15, 10, 18, 14])\n    variance = np.var(data)\n    \n    print(\"Variance:\", variance)\n    \n    # Output\n        \n    # Variance: 7.359999999999999\n    \n    \\end{lstlisting}\n\\end{itemize}\n\nThese summary statistics are essential components of exploratory data analysis, and we will delve deeper into their significance in the upcoming lessons.\n\n\\subsection{Broadcasting}\nBroadcasting is a clever feature in NumPy that allows us to perform operations on arrays of different shapes without the need for explicit reshaping into the same dimensions. Imagine we have two arrays, one smaller and one larger, and we want to add them together. NumPy makes this possible by implicitly extending the smaller array to match the shape of the larger one. For example, if we have a 2D array with dimensions (3, 4) and a 1D array with dimensions (4), we can directly add them together. NumPy will automatically expand the 1D array along its rows to make it a 2D array, and then it performs element-wise addition. This makes our code more concise and easier to read, as we don't have to manually reshape or loop through the data. Broadcasting is a powerful tool for working with arrays of varying shapes efficiently, making it an essential concept in NumPy for data manipulation and analysis. Let's consider the below example for more clarity:\n\\begin{lstlisting}[language=Python]\nimport numpy as np\n\nA = np.array([[1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]])\nB = np.array([1, 0, 1, 0])\n\nresult = A + B\nprint(result)\n\\end{lstlisting}\n\nIn this example, broadcasting enables us to add the 1D array B to the 2D array A directly. NumPy takes care of the stretching of the smaller array, allowing for straightforward element-wise addition. Below is the output of the program:\n\n\\begin{lstlisting}[language=Python]\n[[ 2  2  4  4]\n [ 6  6  8  8]\n [10 10 12 12]]\n\\end{lstlisting}\n\n\nBroadcasting not only simplifies our code but also makes it more efficient and readable when working with arrays of different shapes.\n\n\\subsection{Comparisons, Masks, and Boolean Logic}\nBoolean masking in NumPy equips us with a strong tool for data exploration and analysis. Boolean masks allow us to effortlessly extract, modify, or filter data based on specific conditions. In the world of data analysis, Boolean masking is the efficient and effective way to reveal valuable insights hidden within complex datasets. Let's explore in the part of our lesson how Boolean masking works.\n\n\\subsubsection{Example: Seattle Rain Dataset}\nIn order to explain the concept of Boolean masks, we will practice together its importance and need through a practical example on the \"Seattle2014.csv\" dataset. The data contains rain precipitation information about the year 2014 in the city of Seattle.\n\n\\textit{\\textbf{Don't wait, download the dataset file (Seattle2014.csv) and let's practice together in the Jupyter Notebook. }}\n\nLet us explore the rain information provided by this dataset. First, we will load the data using pandas (which we will discover in the next lesson), then read the information from the PRCP column, which contains the daily rain statistics in Seattle. Once we get the PRCP data, we will divide by 254 to get the rainfall inches.\n\n\\begin{lstlisting}[language=Python]\nimport numpy as np\nimport panadas as pd\n\nrainfall = pd.read_csv('./Seattle2014.csv')['PRCP'].values\ninches = rainfall / 254 # Convert the precipitation to inches\ninches.shape\n\\end{lstlisting}\n\nWe can notice in this code, that we directly divided rainfall by 254, utilizing the division UFunc we explored earlier. The output of inches.shape is 365, referring to the number of days in a year.\n\nLet us get some insight about the distribution of rain throughout the year by plotting a histogram. We will cover histogram plotting and the use of Matplotlib and Seaborn packages next week. So also don't worry about the below code for now. What we need to know is some useful information out of this data.\n\n\\begin{lstlisting}[language=Python]\nimport matplotlib.pyplot as plt\nimport seaborn; seaborn.set() # set plot styles\n\nplt.hist(inches, 40);\n\\end{lstlisting}\n\nThe output of the above code is a histogram of the rain distribution:\n\\begin{figure}\n    \\centering\n    \\includegraphics{Images/Seattle_rain_distribution.png}\n    \\caption{Rain Distribution in Seattle 2014 (inches)}\n    \\label{fig:enter-label}\n\\end{figure}\n\nIn this Figure, we were able to extract the frequency of each rainfall volume, where most of them are zero. This information is not very useful for us. However, we need to extract better analysis, such as how many rainy days are there in a year? how many rainy days with more than half inch of rain? what is the average rain of those days? All of these questions can be addressed by using the Boolean masks feature of NumPy. Note that we care about this information because whenever we are dealing with a dataset, we have to understand its underlying structure and information conveys. All of this should be done before even starting building our machine learning solution to do some predictions on it. Now, let's understand how Boolean masks work, then we go back to extract these information from the Seattle2014 dataset.\n\n\\subsubsection{Comparison Operators}\nWe previously introduced universal functions (UFuncs) in NumPy, focusing primarily on arithmetic operators like +, -, *, /, and their ability to perform element-wise operations on arrays. NumPy also extends these element-wise operations to comparison operators such as $<$ (less than) and $>$ (greater than). The outcome of using these comparison operators is consistently a Boolean array, where each element represents the result of the comparison. All six standard comparison operations are available for use: less than, greater than, less than or equal, greater than or equal, not equal, and equal. For example, when we apply these operators to an array x, we get Boolean arrays as results:\n\\begin{lstlisting}[language=Python]\nx = np.array([1, 2, 3, 4, 5])\nx < 3  # Outputs: array([True, True, False, False, False], dtype=bool)\nx > 3  # Outputs: array([False, False, False, True, True], dtype=bool)\n# ... and so on\n\\end{lstlisting}\n\nAdditionally, NumPy allows for element-wise comparisons between two arrays. These comparison operators are implemented as UFuncs within NumPy, enhancing their versatility and compatibility with arrays of various sizes and shapes. For instance, when we write \\textit{x $<$ 3}, NumPy internally uses \\textit{np.less(x, 3)}. Below is a summary of the comparison operators and their corresponding UFuncs:\n\\begin{itemize}\n    \\item == is equivalent to \\textit{np.equal}\n    \\item $!=$ is equivalent to \\textit{np.not\\_equal}\n    \\item $<$ is equivalent to \\textit{np.less}\n    \\item $<=$ is equivalent to \\textit{np.less\\_equal}\n    \\item $>$ is equivalent to \\textit{np.greater}\n    \\item $>=$ is equivalent to \\textit{np.greater\\_equal}\n\\end{itemize}\n\nThese comparisons offer a seamless way to work with Boolean results, and they can be employed on arrays of varying dimensions.\n\n\\subsubsection{Boolean Arrays}\nWhen working with Boolean arrays in NumPy, a range of operations can be applied to extract meaningful information. Let's explore how to work with Boolean arrays using a two-dimensional array 'x' as an example:\n\\begin{lstlisting}[language=Python]\nimport numpy as np\n\nx = np.array([[8, 2, 4, 4],\n              [6, 10, 4, 7],\n              [3, 5, 9, 1]])\n\\end{lstlisting}\n\n\\subsubsection*{Counting Entries:}\nTo count the number of \\textit{True} entries in a Boolean array, we can employ \\textit{np.count\\_nonzero}. For example, if we want to find out how many values in array \\textit{x} are less than \\textit{6}:\n\\begin{lstlisting}[language=Python]\n# Count the number of values less than 6\nnp.count_nonzero(x < 6)  # Outputs: 7\n\\end{lstlisting}\nAlternatively, we can achieve the same result using \\textit{np.sum}, where \\textit{False} is considered as 0 and \\textit{True} as 1:\n\\begin{lstlisting}[language=Python]\nnp.sum(x < 6)  # Outputs: 7\n\\end{lstlisting}\nIn this example, we use the \\textit{sum} function to count the number of values less than 6 in \\textit{x}.\n\n\\subsubsection*{Checking for 'Any' and 'All' Values:}\nTo quickly check if any or all values meet specific conditions, we can use \\textit{np.any()} and \\textit{np.all()}. For instance, we can check if there are any values greater than 8 in \\textit{x}:\n\\begin{lstlisting}[language=Python]\nnp.any(x > 8)  # Outputs: True\n\\end{lstlisting}\n\nSimilarly, if we want to check if all values are greater than 0, we get \\textit{True}. Here is how we can do it:\n\n\\begin{lstlisting}[language=Python]\nnp.all(x > 0)  # Outputs: True\n\\end{lstlisting}\n\n\n\\subsubsection{Boolean Operators \\& Masks On The Seattle Dataset}\nIn our previous discussions, we learned how to count days with specific rainfall levels, such as those with rain less than four inches or greater than two inches. But what if we want to find days with rain that falls within a range, for example, between one and four inches? This is where Python's logic operators, represented by \\& and $|$, come into play. Just like arithmetic operators, NumPy treats these logic operators as universal functions (ufuncs) that work element-wise, primarily on Boolean arrays.\n\nTo illustrate this, let's consider a compound question like the number of days with rainfall between 0.5 and 1.0 inches:\n\n\\begin{lstlisting}[language=Python]\nnp.sum((inches > 0.5) & (inches < 1))  # Outputs: 29\n\\end{lstlisting}\n\nAnother example is using the or operation $|$:\n\\begin{lstlisting}[language=Python]\nnp.sum((inches > 0.5) | (inches > 0.4))  # Outputs: Returns all values greater than 0.4\n\\end{lstlisting}\n\nThese powerful tools enable us to answer a variety of questions about our weather data. Here are some examples of the results we can compute by combining Boolean masking with aggregation functions:\n\n\\begin{itemize}\n    \\item \\textbf{The number of days without any rain:}\n    \\begin{lstlisting}[language=Python]\n        print(\"Number days without rain: \", np.sum(inches == 0))\n\n        # Output\n        # Number days without rain:  215\n    \\end{lstlisting}\n\n    \\item \\textbf{The number of days with any amount of rain:}\n    \\begin{lstlisting}[language=Python]\n        print(\"Number days with rain: \", np.sum(inches != 0))\n\n        # Output\n        # Number days with rain:  150\n    \\end{lstlisting}\n\n    \\item \\textbf{The count of days with more than 0.5 inches of rain:}\n    \\begin{lstlisting}[language=Python]\n        print(\"Days with more than 0.5 inches:\", np.sum(inches > 0.5))\n\n        # Output\n        # Days with more than 0.5 inches: 37\n    \\end{lstlisting}\n\n    \\item \\textbf{The count of rainy days with less than 0.1 inches of rain:}\n    \\begin{lstlisting}[language=Python]\n        print(\"Rainy days with < 0.1 inches:\", np.sum((inches > 0) & (inches < 0.2)))\n\n        # Output\n        # Rainy days with < 0.1 inches: 75\n    \\end{lstlisting}\n    \n\\end{itemize}\n\nThese examples demonstrate how to use Boolean masking with NumPy to perform various aggregations and answer specific questions about your weather data.\n\n\\textit{\\textbf{Note: }Remember that you should learn by practice. Before you move to the practical exercise of this week, attempt to run these examples on your notebook and try to play with the values and conditions! }\n\n\\subsection{Additional Exercises With Useful NumPy Functions}\nNumPy offers a variety of functions that are essential for data analysis and manipulation. In this section, we will explore three particularly valuable functions: \\textit{np.argmax()}, \\textit{np.unique()}, and \\textit{np.digitize()}. These functions play a pivotal role in AI and data science, enabling us to extract meaningful insights from datasets, identify unique values, and categorize data into bins. \\textit{It's crucial to focus on these functions, as they will be used in the practical exercises}, allowing you to harness the power of NumPy in real-world applications. Let's dive into these essential tools:\n\n\\subsubsection{np.argmax()}\nThe goal of this exercise is to identify the peak value in a dataset and its position.\n\\begin{lstlisting}[language=Python]\ndata = np.array([10, 25, 30, 15, 5, 20, 15])\npeak_position = np.argmax(data)\npeak_value = data[peak_position]\nprint(peak_value)\n\\end{lstlisting}\nBy using \\textit{np.argmax}, we pinpoint the index of the peak value within the \\textit{data} array. This information allows us to extract the peak value from the dataset, which can be vital for detecting trends or anomalies in various applications, such as stock price analysis or sensor data processing.\n\n\\begin{lstlisting}[language=Python]\n#Output\n30\n\\end{lstlisting}\n\n\\subsubsection{np.unique()}\nIn this exercise, we aim to determine the unique elements in an array and count the occurrences of each unique element.\n\\begin{lstlisting}[language=Python]\ndata = np.array([4, 6, 4, 2, 6, 1, 4, 1, 2, 1])\nunique_data, counts = np.unique(data, return_counts=True)\nprint(unique_data)\nprint(counts)\n\\end{lstlisting}\nWith \\textit{np.unique}, we extract the unique values from the \\textit{data} array. By using \\textit{return\\_counts=True}, we also obtain the count of each unique value. Note that when a function returns two objects, we can add two variable (\\textit{unique\\_data, counts}) before the equal sign. This functionality is very important for tasks like analyzing survey responses or classifying items in e-commerce data among other examples.\n\\begin{lstlisting}[language=Python]\n#Output\n[1 2 4 6]\n[3 2 3 2]\n\\end{lstlisting}\n\n\\subsubsection{np.digitize()}\nWe aim in the example to assign data points to predefined bins based on specified bin intervals.\n\\begin{lstlisting}[language=Python]\ndata = np.array([3, 7, 12, 25, 8, 6, 15, 5])\nbins = [0, 5, 10, 20, 30]\nbin_assignments = np.digitize(data, bins)\nprint(bin_assignments)\n\\end{lstlisting}\nThe \\textit{np.digitize} function serves as a powerful tool for binning \\textit{data}, which means dividing a range of values into specific intervals or bins. In this example, we have a dataset stored in the \\textit{data} array, and we want to categorize each data point into predefined bins defined by the \\textit{bins} array. The \\textit{bins} array specifies the bin intervals, such as [0, 5, 10, 20, 30], and \\textit{np.digitize} determines which bin each data point belongs to based on its value. Thus the output of our program is:\n\\begin{lstlisting}[language=Python]\n#Output\n[1 2 3 4 2 2 3 2]\n\\end{lstlisting}\n\nThese practical examples illustrate how these NumPy functions can be applied to diverse real-world scenarios.\n\n\\subsection{Link to Pandas}\nHaving gained a solid grasp of NumPy, we're now ready to delve into Pandas. Think of Pandas as the tool that helps us make sense of data. While NumPy is fantastic for numbers, Pandas adds the magic touch for handling all kinds of data. In AI, data is the starting point, and Pandas is your go-to assistant for preparing and exploring it. Therefore, we will study the Pandas package in the next lesson. Pandas will be our helper in later stage when we decide to do some data cleaning and preprocessing at a later stage, which we will discuss in more details in Week \\#7.\n\n% \\subsection{Creating Numpy Arrays and Accessing Elements}\n% [Page content]\n\n\n\n% \\subsection{Performing Basic Operations With Numpy Arrays}\n% [Page content]\n\n\n\n% \\subsection{Broadcasting and Vectorization in Numpy}\n% [Page content]\n\n\n\n% \\subsection{Common Mathematical Functions and Statistical Operations With Numpy}\n% [Page content]\n\n\n\n\\subsection{Summary}\nIn Summary, this lesson has provided us with a comprehensive understanding of NumPy and its essential features. We've learned how to create NumPy arrays, perform basic NumPy array operations, and apply various mathematical functions. These skills are fundamental for data analysis, and we're now well-equipped to work with data to extract basic statistical information.\n\nAs we move forward, the next lesson will introduce Pandas, a powerful library that builds upon NumPy's foundation. Pandas will empower us to work with structured data more efficiently, offering extensive tools for data manipulation, analysis, and visualization. By mastering both NumPy and Pandas, we'll gain a strong foundation in data handling and be well-prepared to tackle more advanced data analysis tasks as part of developing a Machine Learning solution.\n\nBefore starting with the next lesson about Pandas, make sure to review the NumPy material and practice well with the practical exercises on the Heart Disease Prediction dataset.\n\n\n\n\\subsection{Self-Evaluation Quiz: NumPy [(60 mins]}\nTake this quiz to evaluate your knowledge of NumPy after this lesson. Feel free to take this quiz as many times as needed. Please download \\textit{Week 6 - Pandas Exercises.ipynb} notebook file, you will find the code of all the quesitons inside. The dataset we are using is the Heart Failure Prediction. Therefore, make sure you have the heart.csv file in the same folder. You can always use your Jupyter Notebook to verify your answers. Answer carefully the following questions.\n\n\\subsubsection*{Questions 1}\nWhat is the purpose of the following code?\n\n\\begin{lstlisting}[language=Python]\nnp_data = np.array(data)\n\\end{lstlisting}\n\na) To create a Python list from a NumPy array.\\\\\nb) To convert a NumPy array to a Python list.\\\\\nc) To calculate the sum of elements in a NumPy array.\\\\\nd) To convert data from a Python list to a NumPy array.\\\\\n\n\\textbf{Answer:}\nd) To convert data from a Python list to a NumPy array.\n\n\\noindent\\rule{10cm}{0.4pt}\n\n\\subsubsection*{Question 2}\n\\begin{lstlisting}[language=Python]\nchest_pain_column = np_data[:, 2]\nunique_values, column = np.unique(chest_pain_column, return_counts=True)\nfor index in range(len(column)):\n    print(column[index], unique_values[index])\n\\end{lstlisting}\n\nWhat is the purpose of the 'unique\\_values' variable in the given code snippet?\\\\\n\na) It contains the counts of each chest pain type.\\\\\nb) It contains the unique values of the 'ChestPainType' column.\\\\\nc) It contains the total number of data points in the dataset.\\\\\nd) It contains the indexes of unique chest pain types.\\\\\n\n\\textbf{Answer:}\nb) It contains the unique values of the 'ChestPainType' column.\n\n\\textbf{Justification:}\nThe 'unique\\_values' variable is assigned the unique values of the 'ChestPainType' column, as indicated by the 'np.unique' function.\n\n\\subsubsection*{Question 3}\n\\begin{lstlisting}[language=Python]\nchest_pain_column = np_data[:, 2]\nunique_values, column = np.unique(chest_pain_column, return_counts=True)\nfor index in range(len(column)):\n    print(column[index], unique_values[index])\n\\end{lstlisting}\n\nWhat is the purpose of the 'for' loop in the provided code?\\\\\na) It prints the counts of chest pain types.\\\\\nb) It calculates the average of chest pain counts.\\\\\nc) It prints the values in the 'unique\\_values' array.\\\\\nd) It sorts the unique chest pain types alphabetically.\\\\\n\n\\textbf{Answer:}\na) It prints the counts of chest pain types.\n\n\\textbf{Justification:}\nThe 'for' loop iterates through the 'column' variable, which contains the counts of each unique chest pain type, and prints the counts.\n\n\\subsubsection*{Question 4}\n\\begin{lstlisting}[language=Python]\nchest_pain_column = np_data[:, 2]\nunique_values, column = np.unique(chest_pain_column, return_counts=True)\nfor index in range(len(column)):\n    print(column[index], unique_values[index])\n\\end{lstlisting}\nIn the context of the code, what does the 'return\\_counts=True' parameter in the 'np.unique' function do?\\\\\na) It returns the unique chest pain types.\\\\\nb) It sorts the 'ChestPainType' values in ascending order.\\\\\nc) It returns the counts of each unique chest pain type.\\\\\nd) It converts the 'ChestPainType' values to lowercase.\\\\\n\n\\textbf{Answer:}\nc) It returns the counts of each unique chest pain type.\n\n\\textbf{Justification:}\nThe 'return\\_counts=True' parameter in the 'np.unique' function makes it return not only the unique values but also their corresponding counts. It provides the counts of each unique chest pain type, which is what the code is using in the 'for' loop to print the counts of occurrences.\n\n\\noindent\\rule{10cm}{0.4pt}\n\n\\subsubsection*{Question 5}\n\\begin{lstlisting}[language=Python]\ncholesterol_column = np_data[:, 4]\nthreshold = 360\ncholesterol_column = cholesterol_column.astype(float)\n# Create a boolean mask to filter rows\nmask = cholesterol_column > threshold\n# Use the boolean mask to filter the rows\nfiltered_data = np_data[mask]\n\\end{lstlisting}\n\nWhat is the ultimate goal or purpose of this code snippet?\\\\\na) To calculate the average cholesterol level in the dataset.\\\\\nb) To identify and store data of patients with high cholesterol.\\\\\nc) To extract the age of patients with high cholesterol.\\\\\nd) To filter patients below a certain age.\\\\\n\n\\textbf{Answer:}\nb) To identify and store data of patients with high cholesterol.\n\n\\textbf{Justification:}\nThe primary objective of this code is to identify and store data of patients with high cholesterol by filtering the dataset based on a cholesterol threshold.\n\n\\subsubsection*{Question 6}\n\\begin{lstlisting}[language=Python]\ncholesterol_column = np_data[:, 4]\nthreshold = 360\ncholesterol_column = cholesterol_column.astype(float)\n# Create a boolean mask to filter rows\nmask = cholesterol_column > threshold\n# Use the boolean mask to filter the rows\nfiltered_data = np_data[mask]\n\\end{lstlisting}\n\nWhat is the significance of the 'filtered\\_data' variable in the context of the code?\\\\\na) It represents the average cholesterol level of high-cholesterol patients.\\\\\nb) It contains the data of all patients in the dataset.\\\\\nc) It holds data points of patients with cholesterol levels above the threshold.\\\\\nd) It calculates the total number of patients with high cholesterol.\\\\\n\n\\textbf{Answer:}\nc) It holds data points of patients with cholesterol levels above the threshold.\n\n\\textbf{Justification:}\nThe 'filtered\\_data' variable is used to store data points of patients with cholesterol levels above the specified threshold, effectively identifying patients with high cholesterol.\n\n\\noindent\\rule{10cm}{0.4pt}\n\n\\subsubsection*{Question 7}\n\\begin{lstlisting}[language=Python]\ngender_column = np_data[:, 1]\nheart_rate_column = np_data[:, 7]\n\nmale_mask = gender_column == 'M'\nfemale_mask = gender_column == 'F'\n\naverage_heart_rate_male = np.mean(heart_rate_column[male_mask].astype(float))\naverage_heart_rate_female = np.mean(heart_rate_column[female_mask].astype(float))\n\nprint(f'Average Heart Rate for Males (M): {average_heart_rate_male}')\nprint(f'Average Heart Rate for Females (F): {average_heart_rate_female}')\n\\end{lstlisting}\n\nWhat is the primary goal of this code snippet?\\\\\na) To count the number of male and female patients.\\\\\nb) To identify patients with high heart rates.\\\\\nc) To calculate the average maximum heart rate for male and female patients.\\\\\nd) To sort the patients based on their heart rate values.\\\\\n\n\\textbf{Answer:}\nc) To calculate the average maximum heart rate for male and female patients.\n\n\\textbf{Justification:}\nThe code calculates and prints the average maximum heart rate for both male and female patients.\n\n\\subsubsection*{Question 8}\n\\begin{lstlisting}[language=Python]\ngender_column = np_data[:, 1]\nheart_rate_column = np_data[:, 7]\n\nmale_mask = gender_column == 'M'\nfemale_mask = gender_column == 'F'\n\naverage_heart_rate_male = np.mean(heart_rate_column[male_mask].astype(float))\naverage_heart_rate_female = np.mean(heart_rate_column[female_mask].astype(float))\n\nprint(f'Average Heart Rate for Males (M): {average_heart_rate_male}')\nprint(f'Average Heart Rate for Females (F): {average_heart_rate_female}')\n\\end{lstlisting}\n\nWhat would happen if we omitted the 'male\\_mask' and 'female\\_mask' variables and directly calculated the average heart rates without filtering by gender?\\\\\na) The code would run faster and be more efficient.\\\\\nb) It would produce inaccurate average heart rate values.\\\\\nc) The code would not run as intended due to syntax errors.\\\\\nd) It would result in a combined average heart rate for all patients.\\\\\n\n\\textbf{Answer:}\nd) It would result in a combined average heart rate for all patients.\n\n\\textbf{Justification:}\nThe 'male\\_mask' and 'female\\_mask' variables are crucial for filtering the data based on gender, enabling the calculation of gender-specific average maximum heart rates. Without these masks, the code would produce a combined average heart rate for all patients, which might not be useful in this context.\n\n\\subsubsection*{Question 9}\n\\begin{lstlisting}[language=Python]\ngender_column = np_data[:, 1]\nheart_rate_column = np_data[:, 7]\n\nmale_mask = gender_column == 'M'\nfemale_mask = gender_column == 'F'\n\naverage_heart_rate_male = np.mean(heart_rate_column[male_mask].astype(float))\naverage_heart_rate_female = np.mean(heart_rate_column[female_mask].astype(float))\n\nprint(f'Average Heart Rate for Males (M): {average_heart_rate_male}')\nprint(f'Average Heart Rate for Females (F): {average_heart_rate_female}')\n\\end{lstlisting}\n\nIn the context of the code, what is the purpose of the 'male\\_mask' and 'female\\_mask' variables?\\\\\na) They represent the number of male and female patients.\\\\\nb) They are used to count the number of male and female patients.\\\\\nc) They are filters that identify male and female patients based on gender.\\\\\nd) They store the average heart rates for male and female patients.\\\\\n\n\\textbf{Answer:}\nc) They are filters that identify male and female patients based on gender.\n\n\\textbf{Justification:}\nThe 'male\\_mask' and 'female\\_mask' variables are used to filter and identify male and female patients based on their gender for calculating average heart rates.\n\n\\noindent\\rule{10cm}{0.4pt}\n\n\\subsubsection*{Question 10}\n\\begin{lstlisting}[language=Python]\nimport numpy as np\n\nage_bins = [18, 30, 40, 50, 60, np.inf]  # np.inf represents positive infinity\nage_labels = ['18-30', '31-40', '41-50', '51-60', '61+']\nage_column = np_data[:, 0].astype(int)\n\nage_group_indices = np.digitize(age_column, age_bins)\n\ngrouped_patients = []\n\nage_groups = np.array(age_labels)[age_group_indices - 1]\n\nunique_age_groups = np.unique(age_groups)\n\nfor label in unique_age_groups:\n    mask = age_groups == label\n    grouped_patients.append(np_data[mask])\n\nprint(grouped_patients)\n\\end{lstlisting}\n\nWhat is the primary objective of the code snippet provided?\\\\\na) To calculate the average age of the patients in the dataset.\\\\\nb) To identify patients with specific age-related medical conditions.\\\\\nc) To group patients into different age ranges and store them in separate arrays.\\\\\nd) To find the total number of patients in the dataset.\\\\\n\n\\textbf{Answer:}\nc) To group patients into different age ranges and store them in separate arrays.\n\n\\textbf{Justification:}\nThe code groups patients into different age ranges and stores them in separate arrays based on age group indices.\n\n\\subsubsection*{Question 11}\n\\begin{lstlisting}[language=Python]\nimport numpy as np\n\nage_bins = [18, 30, 40, 50, 60, np.inf]  # np.inf represents positive infinity\nage_labels = ['18-30', '31-40', '41-50', '51-60', '61+']\nage_column = np_data[:, 0].astype(int)\n\nage_group_indices = np.digitize(age_column, age_bins)\n\ngrouped_patients = []\n\nage_groups = np.array(age_labels)[age_group_indices - 1]\n\nunique_age_groups = np.unique(age_groups)\n\nfor label in unique_age_groups:\n    mask = age_groups == label\n    grouped_patients.append(np_data[mask])\n\nprint(grouped_patients)\n\\end{lstlisting}\n\nWhat is the purpose of the 'age\\_bins' and 'age\\_labels' lists in the code?\\\\\na) They define the age range categories and their corresponding labels.\\\\\nb) They calculate the average age of the patients in the dataset.\\\\\nc) They filter patients with specific medical conditions.\\\\\nd) They represent age values in the dataset.\\\\\n\n\\textbf{Answer:}\na) They define the age range categories and their corresponding labels.\n\n\\textbf{Justification:}\nThe 'age\\_bins' list defines the age range categories, and the 'age\\_labels' list provides corresponding labels for those categories.\n\n\\subsubsection*{Question 12}\n\\begin{lstlisting}[language=Python]\nimport numpy as np\n\nage_bins = [18, 30, 40, 50, 60, np.inf]  # np.inf represents positive infinity\nage_labels = ['18-30', '31-40', '41-50', '51-60', '61+']\nage_column = np_data[:, 0].astype(int)\n\nage_group_indices = np.digitize(age_column, age_bins)\n\ngrouped_patients = []\n\nage_groups = np.array(age_labels)[age_group_indices - 1]\n\nunique_age_groups = np.unique(age_groups)\n\nfor label in unique_age_groups:\n    mask = age_groups == label\n    grouped_patients.append(np_data[mask])\n\nprint(grouped_patients)\n\\end{lstlisting}\n\nWhy is the 'np.digitize' function used in the code?\\\\\na) To calculate the mean age of the patients in each age group.\\\\\nb) To sort the patients' data based on their age.\\\\\nc) To create indices for grouping patients into specific age ranges.\\\\\nd) To count the total number of patients in each age group.\\\\\n\n\\textbf{Answer:}\nc) To create indices for grouping patients into specific age ranges.\n\n\\textbf{Justification:}\nThe 'np.digitize' function is used to create age group indices, which are used for grouping patients into specific age ranges.\n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]\n\n\\subsection{Share and Compare: Numpy [30 mins] }\n\\subsubsection*{Your task}\nShare and compare your answers and challenges faced when solving the self evaluation quiz.\n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]", "metadata": {"source": "./full-course/aai.txt"}}}