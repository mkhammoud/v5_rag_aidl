{"lc": 1, "type": "constructor", "id": ["langchain", "schema", "document", "Document"], "kwargs": {"page_content": "{Lesson 2: Lists}\n\\subsection{Introduction}\nIn this lesson, we will discover the lists in Python and how they can simplify data storage and manipulation. Lists are a fundamental data structure in Python, allowing us to store collections of elements in a single container. They offer several benefits, such as easy access to individual elements and dynamic resizing.\n\nThroughout this lesson, we will learn how to create and initialize lists, access and modify their elements, and use list methods to perform common operations efficiently. By the end of this lesson, we will have a solid understanding of Python lists.\n\n\\subsection{Why We Need Lists}\nIn Python, lists play an important role as a general mechanism for storing collections of elements. Lists offer the advantage of being indexed by a numerical value, which allows easy access to individual elements within the list. This indexing capability simplifies data handling and manipulation, making lists a useful tool in various programming scenarios, particularly for applied AI tasks.\n\n\\subsubsection{Arbitrary Elements:}\nLists in Python are flexible as they allow for the storage of a wide range of data types. Whether you need to store numbers, strings, or even other lists, a single list can accommodate them all. This flexibility makes lists ideal for representing complex data structures in a straightforward and concise manner.\n\n\\subsubsection{Dynamic Size:}\nUnlike some other data structures in Python, lists can dynamically change in size during program execution. We can add or remove elements from a list as needed, making it a good choice for handling data with variable or unpredictable size. So, the dynamic resizing capability in lists allows greater control when dealing with datasets of varying sizes, which is often encountered in real-world AI applications.\n\n\\subsubsection{Iterability:}\nLists are iterable objects, meaning you can easily traverse through their elements using iteration techniques, which we will discover later in this week's lessons. This provides us with the ability of performing repeated operations on elements of the list. Such operations can be aggregating data or applying specific algorithms to each element.\n\n\\subsubsection{Simple Syntax:}\nPython's syntax for creating and manipulating lists is elegant and intuitive. With just a few lines of code, we can define a list, populate it with elements, and perform various operations on it. This simplicity not only aids in the readability of our code but also speeds up development.\n\n\\subsubsection{Seamless Integration with AI Algorithms:}\nIn applied AI, working with datasets is a fundamental part of the process. Lists provide a natural and seamless way to represent data, which aligns well with the algorithms used in AI tasks. Whether we are processing numerical data for machine learning solutions or managing textual data, lists offer a unified and efficient approach to handle diverse data types.\n\n\\subsection{Creating and Initializing Lists}\nIn Python, lists provide a way to store collections of elements. To create a list, we can surround a comma-separated list of elements with square brackets ([]). Let's explore various examples of creating and initializing lists:\n\n\\textbf{\\textit{Example 1 - A List of Numbers:}}\n\\begin{lstlisting}[language=Python]\n    # Create a list of numbers\n    numbers = [2, 5, 10, 17, 22, 31]\n    print(numbers)\n    # Output: [2, 5, 10, 17, 22, 31]\n\\end{lstlisting}\n\\textbf{\\textit{Example 2 - List with Multiple Lines:}}\n\\begin{lstlisting}[language=Python]\n    # Create a list with entries spanning multiple lines\n    fruits = [\n        'apple',\n        'banana',\n        'orange',\n        'mango',\n        'kiwi'\n    ]\n    print(fruits)\n    # Output: ['apple', 'banana', 'orange', 'mango', 'kiwi']\n\\end{lstlisting}\n\\textbf{\\textit{Example 3 - Mixed Data Types in a List:}}\n\\begin{lstlisting}[language=Python]\n# Create a list with mixed data types\nmixed_list = [7, 'dog', 3.14, [1, 5, 2, 7], True]\nprint(mixed_list)\n# Output: [7, 'dog', 3.14, [1, 5, 2, 7], True]\n\\end{lstlisting}\n\n\\textbf{\\textit{Example 4 - Nested Lists:}}\n\\begin{lstlisting}[language=Python]\n# Create a nested list\nnested_list = [1, 2, [10, 20, 30, [7, 9, 11, [100, 200, 300]]], [1, 7, 8]]\nprint(nested_list)\n# Output: [1, 2, [10, 20, 30, [7, 9, 11, [100, 200, 300]]], [1, 7, 8]]\n\\end{lstlisting}\n\nIn the examples above, we created lists with different types of data, including numbers, strings, floating-point values, and other lists. Python's flexible nature allows us to combine diverse data elements in a single list effortlessly.\n\nRemember that elements within a list can be of different types, and Python provides a simple and concise way to represent complex data structures.\n\n\\textbf{\\textit{Example 5 - Creating an Empty List:}}\nTo create an empty list, use square brackets with no elements in between them ([ ]):\n\\begin{lstlisting}[language=Python]\n    # Create an empty list\n    empty_list = []\n    print(empty_list)\n\\end{lstlisting}\n\nPython's ability to handle empty lists is beneficial for scenarios where you need to collect data later in your program dynamically.\n\n\\subsection{Accessing and Manipulating List Elements}\nNow that we know how to create lists, it's time to explore how we can access and manipulate their elements. Understanding these operations is fundamental to effectively work with data stored in lists for applied AI tasks.\n\n\\subsubsection{Accessing List Elements}\nTo access individual elements in a list, we use square brackets ([]) after the list's name, containing the index of the desired element. It's important to remember that \\textbf{Python uses zero-based indexing}, meaning the first element has an index of 0, the second element has an index of 1, and so on.\nIn the example below, we create a list named \"colors\", which contains a string of five different colors: red, green, blue, yellow, and purple.\n\\textbf{\\textit{Example 1 - Accessing Elements:}}\n\\begin{lstlisting}[language=Python]\n    # Create a list of colors\n    colors = ['red', 'green', 'blue', 'yellow', 'purple']\n    \n    # Access elements by their index\n    first_color = colors[0]\n    third_color = colors[2]\n    print(first_color)  # Output: 'red'\n    print(third_color)  # Output: 'blue'\n\\end{lstlisting}\n\nIn order to access the first element of the list, we use index zero by writing: \"colors[0]\". Writing the name of the list followed by brackets that includes the index is the correct syntax. We store \"colors[0]\" in a variable named \"first\\_color\" by writing: \"first\\_color = colors[0]\". Now printing \"first\\_color\" using \"print(first\\_color)\" outputs \"red\".\n\n\\subsubsection{Manipulating List Elements}\nLists are mutable, which means we can modify their elements after creation. Let's explore some common list manipulation techniques:\n\n\\textbf{\\textit{Example 2 - Modifying Elements:}}\nIn this example, our goal is to modify items of an existing list. In the code below, we create a list of five numbers, from 1 to 5.\n\\begin{lstlisting}[language=Python]\n    # Create a list of numbers\n    numbers = [1, 2, 3, 4, 5]\n    \n    # Modify elements in the list\n    numbers[2] = 10\n    numbers[4] = 25\n    print(numbers)  # Output: [1, 2, 10, 4, 25]\n\\end{lstlisting}\nIn order to modify the third number in the list, we use index 2. The third element in the list at index 2 is 3. In order to modify 3 to become 10, we write: \\textit{numbers[2] = 10}. As we learned earlier, we put the variable we want to update on the left side of the equal sign. In this case, we want to update numbers[2].\\\\\nWe also do the same for the fifth element in the list, having index 4 (remember that indexing in Python starts from zero). Hence, we write \\textit{number[4] = 25} to update the fifth element, which is 5, to become 25.\\\\\nFinally, if we print the new updated list, we get: [1, 2, 10, 4, 25].\n\n\\textbf{\\textit{Example 3 - Appending Elements:}}\nThe purpose of this example is to add elements to a list that we define. In Python, we append elements using the \"append()\" method, which adds elements to the end of the list.\\\\\nIn the below code, we create a list named fruits that contains three colors. Afterward, we call the method append() on the list and pass the new element as a parameter. This is possible by writing: \\textit{fruits.append('mango')}. Finally, printing the content of the fruits list would result in four elements, where 'mango' is the last one.\n\\begin{lstlisting}[language=Python]\n    # Create a list of fruits\n    fruits = ['apple', 'orange', 'banana']\n    \n    # Append a new fruit to the list\n    fruits.append('mango')\n    print(fruits)  # Output: ['apple', 'orange', 'banana', 'mango']\n\\end{lstlisting}\n\n\\textbf{\\textit{Example 4 - Removing Elements:}}\nThe purpose of this fourth example is to remove elements from an existing list. In the below code, we start first by creating a list, named temperatures, containing five numbers. Afterward, we use the method remove() on the list name to remove an element from it. By calling \\textit{temperatures.remove(32)}, the method searches for the number 32 in the list and removes it. Now printing the content of the list, we get four numbers excluding 32.\n\\begin{lstlisting}[language=Python]\n    # Create a list of temperatures\n    temperatures = [28, 30, 32, 27, 29]\n    \n    # Remove an element from the list\n    temperatures.remove(32)\n    print(temperatures)  # Output: [28, 30, 27, 29]\n\\end{lstlisting}\n\n\\subsubsection{Summary}\n\nIn this lesson, we've learned how to access and manipulate list elements in Python. We discovered that lists use zero-based indexing, allowing us to retrieve specific elements by their index. Moreover, we explored how lists are mutable, enabling us to modify elements, append new elements, and remove existing ones.\n\nMastering these list operations is crucial for efficient data handling in applied AI programming. In the next lesson, we'll dive deeper into list indexing and slicing, unlocking even more possibilities for data manipulation.\n\n\\subsection{List Slicing and Indexing}\n\\subsubsection{Accessing Individual Elements by Index}\n\nAs mentioned earlier, individual elements in a list can be accessed using square brackets and the element's index. However, we can also use negative indices to access elements from the end of the list. In Python, -1 refers to the last element, -2 to the second-to-last element, and so on. \\textit{Example 1} illustrates the use of negative and positive indices to access elements.\n\n\\textbf{\\textit{Example 1 - Using Positive and Negative Indices:}}\n\\begin{lstlisting}[language=Python]\n# Create a list of fruits\nfruits = ['apple', 'orange', 'banana', 'mango', 'kiwi']\n    \n# Access elements using positive and negative indices\nfirst_fruit = fruits[0]       # 'apple'\nlast_fruit = fruits[-1]       # 'kiwi'\nsecond_last_fruit = fruits[-2] # 'mango'\n    \nprint(first_fruit, last_fruit, second_last_fruit)\n\\end{lstlisting}\n\n\\subsubsection{List Slicing}\nList slicing is very similar to string slicing, which we saw in week 1, lesson 6.5. List slicing allows us to extract a sub-list from a list. It is done using the colon (:) operator within the square brackets, with the syntax [start:end]. The slicing operation includes all elements from the start index up to, but not including, the end index. If you omit the start index, the slice will begin from the first element (index 0). If you omit the end index, the slice will go up to the last element (index -1). Let us discover how to read a sub-list using an example.\n\n\\textbf{\\textit{Example 2 - List Slicing:}}\n\\begin{lstlisting}[language=Python]\n# Create a list of numbers\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Get a slice of the list\nslice1 = numbers[2:5]     # [3, 4, 5]\nslice2 = numbers[:3]      # [1, 2, 3]\nslice3 = numbers[5:]      # [6, 7, 8, 9]\nslice4 = numbers[2:-2]    # [3, 4, 5, 6, 7]\n\nprint(slice1, slice2, slice3, slice4)\n\\end{lstlisting}\nIn this example, the first slicing we are doing is numbers[2:5]. In this case, we are reading the sublist of numbers, starting from the third element (index 2), up to the fifth element (index 5-1 or 4). The content of variable slice1 would be [3, 4, 5].\\\\\n\nFor the second slicing operation, we wrote numbers[:3]. Leaving the starting point empty, means that we start reading from the first element (index 0). In our case, we read the first three elements from 0 to index 2. Thus, slice2 contains the first three elements: [1, 2, 3].\n\nFor the third slicing example, if the ending index is empty, it means that we stop reading at the last element of the list. writing numbers[5:] means that we start reading from sixth element (index 5) until the last element, which is 9. Hence, the output is: [6, 7, 8, 9].\n\nFinally, numbers[2:-2] indicates that we start reading from the third element in the list (index 2), until the third to the last element (index -3) in the list (element 7). Remember that the end index in the slicing is excluded from the reading. In our case, we stop reading at index -3 instead -2. Finally the output would be: [3, 4, 5, 6, 7].\n\n% \\subsubsection{Step in Slicing}\n\n% You can also specify a step value in list slicing using the syntax [start:end:step]. The step value indicates the number of elements to skip between each element in the slice. A positive step means moving forward through the list, while a negative step means moving backward.\n\n% \\textbf{\\textit{Example 3 - Slicing with a Step:}}\n% \\begin{lstlisting}[language=Python]\n% # Create a list of letters\n% letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j']\n\n% # Get a slice with a step\n% slice_with_step1 = letters[::2]        # ['a', 'c', 'e', 'g', 'i']\n% slice_with_step2 = letters[1::2]       # ['b', 'd', 'f', 'h', 'j']\n% slice_with_step3 = letters[::-1]       # ['j', 'i', 'h', 'g', 'f', 'e', 'd', 'c', 'b', 'a']\n\n% print(slice_with_step1, slice_with_step2, slice_with_step3)\n% \\end{lstlisting}\n\n\\subsubsection{Modifying List Elements with Slicing}\n\nList slicing can also be used to modify specific portions of a list by assigning new values to the selected slice.\n\n\\textbf{\\textit{Example 3 - Modifying List Elements with Slicing:}}\n\\begin{lstlisting}[language=Python]\n# Create a list of numbers\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# Modify a slice of the list\nnumbers[2:5] = [10, 11, 12]\nprint(numbers)  # [1, 2, 10, 11, 12, 6, 7, 8, 9]\n\\end{lstlisting}\n\n\\subsubsection{Summary}\n\nIn this lesson, we explored list slicing and indexing, which are essential techniques for efficiently accessing and manipulating data in Python lists. We learned how to access individual elements using both positive and negative indices. Moreover, we discovered how to create sub-lists using list slicing with optional start, end, and step values. List slicing is a powerful tool that simplifies working with large datasets and extracting relevant information for various AI tasks.\n\nBy understanding list slicing and indexing, you can effectively handle and manipulate lists to prepare data for AI algorithms and advanced data analysis.\n\n\\subsection{List Methods [With Multiplication]}\nPython provides a variety of built-in methods that make working with lists even more powerful and convenient. These methods allow you to perform common operations like adding or removing elements, sorting, and searching without the need for complex code. Let's explore some of the most useful list methods:\n\n\\subsubsection{Adding Elements}\nThere are two methods for adding elements to the list: \\textbf{\\textit{append()}} and \\textbf{\\textit{insert()}}. We have seen the append() method earlier, so let us discover the insert().\n% \\textbf{\\textit{append() Method:}}\n% The append() method adds a new element to the end of the list.\n\n% \\begin{lstlisting}[language=Python]\n% # Create a list of numbers\n% numbers = [1, 2, 3]\n\n% # Add a new number to the list\n% numbers.append(4)\n% print(numbers)  # Output: [1, 2, 3, 4]\n% \\end{lstlisting}\n\n\\textbf{\\textit{insert() Method:}} The insert() method allows you to insert an element at a specific index in the list.\n\\begin{lstlisting}[language=Python]\n# Create a list of numbers\nnumbers = [1, 2, 5]\n\n# Insert a new number at index 2\nnumbers.insert(2, 3)\nprint(numbers)  # Output: [1, 2, 3, 5]\n\\end{lstlisting}\n\n\\subsubsection{Removing Elements}\nThere are two methods for removing elements from a list in Python: \\textbf{\\textit{remove()}} and \\textbf{\\textit{pop()}}. We have already seen the remove() method earlier in this lesson, so let us discover the pop().\n% \\textbf{\\textit{remove() Method:}} The remove() method removes the first occurrence of a specified element from the list.\n% \\begin{lstlisting}[language=Python]\n% # Create a list of numbers\n% numbers = [1, 3, 2, 3, 4]\n\n% # Remove the element 3 from the list\n% numbers.remove(3)\n% print(numbers)  # Output: [1, 2, 3, 4]\n% \\end{lstlisting}\n\n\\textbf{\\textit{pop() Method:}} The pop() method removes and returns the element at a specified index. If no index is provided, it removes and returns the last element.\n\\begin{lstlisting}[language=Python]\n# Create a list of numbers\nnumbers = [1, 2, 3, 4]\n\n# Remove the element at index 1\nremoved_element = numbers.pop(1)\nprint(removed_element)  # Output: 2\nprint(numbers)         # Output: [1, 3, 4]\n\\end{lstlisting}\n\n\\subsubsection{Sorting and Reversing}\n\n\\textbf{\\textit{sort() Method:}} The sort() method arranges the elements of the list in ascending order.\n\\begin{lstlisting}[language=Python]\n# Create a list of numbers\nnumbers = [5, 2, 8, 1, 3]\n\n# Sort the list in ascending order\nnumbers.sort()\nprint(numbers)  # Output: [1, 2, 3, 5, 8]\n\\end{lstlisting}\n\n\\textbf{\\textit{reverse() Method:}} The reverse() method reverses the order of elements in the list.\n\\begin{lstlisting}[language=Python]\n# Create a list of numbers\nnumbers = [1, 2, 3, 4]\n\n# Reverse the order of the list\nnumbers.reverse()\nprint(numbers)  # Output: [4, 3, 2, 1]\n\\end{lstlisting}\n\n\\subsubsection{Using the Multiplication Operator}\n\nThe multiplication operator '*' can be used with lists to create a new list with repeated elements.\n\\begin{lstlisting}[language=Python]\n# Create a list of zeros\nzeros_list = [0] * 5\nprint(zeros_list)  # Output: [0, 0, 0, 0, 0]\n\n# Create a list with repeated elements\nrepeated_list = [1, 2] * 3\nprint(repeated_list)  # Output: [1, 2, 1, 2, 1, 2]\n\\end{lstlisting}\n\n\\subsubsection{Summary}\n\nIn this section, we explored essential list methods that allow us to add, remove, sort, and reverse elements within a list. Python's built-in list methods simplify common list operations, making it easy to manipulate data efficiently.\n\nAdditionally, we saw how the multiplication operator can be used with lists to create new lists with repeated elements.\n\nMastering these list methods will enhance your ability to manage and transform data effectively, which is crucial for various AI applications.\n\n% \\subsection{List Comprehension [Extra]}\n% [Page content]\n\n\n\n\\subsection{Summary}\nIn this lesson, we learned about Python lists and how we can use them for storing collections of elements. Lists offer several advantages, including flexibility in accommodating various data types and dynamic resizing. We explored how to create and initialize lists, access and modify their elements, and use helpful list methods. Now let us do some practice through an exercise about lists!\n\n\\subsection{Practical Exercise: Lists [30 mins]}\n\\subsubsection*{Your task}\nIn this activity, we will apply the knowledge gained in the lesson to work with Python lists and perform various data manipulation tasks. This exercise aims to reinforce your understanding of lists and their operations.\n\n\\textbf{\\textit{Task 1: Create and Modify Lists}}\n\\begin{enumerate}\n    \\item Create a list named \"ages\" with the following age values: 25, 30, 22, 40, and 35.\n    \\item Append the age value of 28 to the end of the list.\n    \\item Insert the age value of 18 at index 1 in the list.\n    \\item Print the modified \"ages\" list to verify the changes.\n\\end{enumerate}\n\n\\textbf{\\textit{Task 2: Extract Sub-lists}}\n\\begin{enumerate}\n    \\item Create a list called \"countries\" with the following elements: 'USA', 'Canada', 'UK', 'Australia', 'Germany', and 'France'.\n    \\item Use list slicing to extract the first three countries and store them in a new list named \"first\\_three\\_countries.\"\n    \\item Use list slicing again to extract the last two countries and store them in a new list named \"last\\_two\\_countries\". \n    \\item Print both \"first\\_three\\_countries\" and \"last\\_two\\_countries\" lists to see the results.\n\\end{enumerate}\n\n\\textbf{\\textit{Task 3: Remove and Sort Lists}}\n\\begin{enumerate}\n    \\item Create a list of numbers named \"random\\_numbers\" with the values: 7, 2, 10, 4, and 1.\n    \\item Remove the number 10 from the list.\n    \\item Sort the \"random\\_numbers\" list in ascending order.\n    \\item Reverse the order of elements in the sorted \"random\\_numbers\" list.\n    \\item Print the final \"random\\_numbers\" list to observe the changes.\n\\end{enumerate}\n\n\\textbf{\\textit{Task 4: Multiplication Operator}}\n\\begin{enumerate}\n    \\item Create a list named \"scores\" containing the elements: 80, 90, and 85.\n    \\item Use the multiplication operator to create a new list named \"repeated\\_scores\" that repeats the elements of \"scores\" two times.\n    \\item Print the \"repeated\\_scores\" list to see the result.\n\\end{enumerate}\n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]\n\n\n\n\\subsection{Model Answer(s): Lists}\n\\textbf{\\textit{Task 1: Create and Modify Lists}}\n\\begin{lstlisting}[language=Python]\n# Task 1: Create and Modify Lists\nages = [25, 30, 22, 40, 35]\n\n# Append the age value of 28 to the end of the list.\nages.append(28)\n\n# Insert the age value of 18 at index 1 in the list.\nages.insert(1, 18)\n\n# Print the modified \"ages\" list to verify the changes.\nprint(ages)\n\\end{lstlisting}\nOutput:\n\\begin{lstlisting}[language=Python]\n[25, 18, 30, 22, 40, 35, 28]\n\\end{lstlisting}\n\n\\textbf{\\textit{Task 2: Extract Sub-lists}}\n\\begin{lstlisting}[language=Python]\n# Task 2: Extract Sub-lists\ncountries = ['USA', 'Canada', 'UK', 'Australia', 'Germany', 'France']\n\n# Use list slicing to extract the first three countries\nfirst_three_countries = countries[:3]\n\n# Use list slicing again to extract the last two countries\nlast_two_countries = countries[-2:]\n\n# Print both \"first_three_countries\" and \"last_two_countries\" lists to see the results.\nprint(first_three_countries)\nprint(last_two_countries)\n\\end{lstlisting}\nOutput:\n\\begin{lstlisting}[language=Python]\n['USA', 'Canada', 'UK']\n['Germany', 'France']\n\\end{lstlisting}\n\n\\textbf{\\textit{Task 3: Remove and Sort Lists}}\n\\begin{lstlisting}[language=Python]\n# Task 3: Remove and Sort Lists\nrandom_numbers = [7, 2, 10, 4, 1]\n\n# Remove the number 10 from the list\nrandom_numbers.remove(10)\n\n# Sort the \"random_numbers\" list in ascending order\nrandom_numbers.sort()\n\n# Reverse the order of elements in the sorted \"random_numbers\" list\nrandom_numbers.reverse()\n\n# Print the final \"random_numbers\" list to observe the changes.\nprint(random_numbers)\n\\end{lstlisting}\nOutput:\n\\begin{lstlisting}[language=Python]\n[7, 4, 2, 1]\n\\end{lstlisting}\n\n\\textbf{\\textit{Task 4: Multiplication Operator}}\n\\begin{lstlisting}[language=Python]\n# Task 4: Multiplication Operator\nscores = [80, 90, 85]\n\n# Use the multiplication operator to create a new list named \"repeated_scores\" that repeats the elements of \"scores\" two times.\nrepeated_scores = scores * 2\n\n# Print the \"repeated_scores\" list to see the result.\nprint(repeated_scores)\n\\end{lstlisting}\n\nOutput:\n\\begin{lstlisting}[language=Python]\n[80, 90, 85, 80, 90, 85]\n\\end{lstlisting}\n\n\\subsection{Share and Compare: Lists [30 mins]}\n\\subsubsection*{Your task}\nDiscussing your solutions and insights will not only strengthen your understanding but also foster a collaborative learning environment.\n\nFeel free to share the outputs of each task and the code you used to achieve them. If you encountered any challenges or found alternative approaches, don't hesitate to share those as well. By engaging in discussions, you can learn from one another's experiences and discover new perspectives on data manipulation using Python lists.\n\n\\subsubsection*{Guidelines}\n[TO BE ADDED BY LD]", "metadata": {"source": "./full-course/aai.txt"}}}